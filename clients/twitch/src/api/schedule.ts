
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetChannelStreamScheduleRequest {
  /**
   * The ID of the broadcaster that owns the streaming schedule you want to
   * get.
   */
  broadcasterId: string,
  /**
   * Not supported.
   */
  utcOffset?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 25 items per page.
   * The default is 20.
   */
  first?: number,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The ID of the scheduled segment to return. To specify more than one
   * segment, include the ID of each segment you want to get. For example,
   * `id=1234&id=5678`. You may specify a maximum of 100 IDs.
   */
  id?: string[],
  /**
   * The UTC date and time that identifies when in the broadcaster’s schedule
   * to start returning segments. If not specified, the request returns
   * segments starting after the current UTC date and time. Specify the date
   * and time in RFC3339 format (for example, `2022-09-01T00:00:00Z`).
   */
  startTime?: string,
}
export interface GetChannelIcalendarRequest {
  /**
   * The ID of the broadcaster that owns the streaming schedule you want to
   * get.
   */
  broadcasterId: string,
}
export interface CreateChannelStreamScheduleSegmentRequest {
  /**
   * The ID of the category that best represents the broadcast’s content. To
   * get the category ID, use the [Search
   * Categories](https://dev.twitch.tv/docs/api/reference#search-categories)
   * endpoint.
   */
  categoryId?: string,
  /**
   * The date and time that the broadcast segment starts. Specify the date and
   * time in RFC3339 format (for example, 2021-07-01T18:00:00Z).
   */
  startTime: string,
  /**
   * The broadcast’s title. The title may contain a maximum of 140
   * characters.
   */
  title?: string,
  /**
   * The length of time, in minutes, that the broadcast is scheduled to run.
   * The duration must be in the range 30 through 1380 (23 hours).
   */
  duration: string,
  /**
   * A Boolean value that determines whether the broadcast recurs weekly. Is
   * **true** if the broadcast recurs weekly. Only partners and affiliates may
   * add non-recurring broadcasts.
   */
  isRecurring?: boolean,
  /**
   * The time zone where the broadcast takes place. Specify the time zone using
   * [IANA time zone database](https://www.iana.org/time-zones) format (for
   * example, America/New\_York).
   */
  timezone: string,
}
export interface DeleteChannelStreamScheduleSegmentRequest {
  /**
   * The ID of the broadcast segment to remove.
   */
  id: string,
}
export interface UpdateChannelStreamScheduleSegmentRequest {
  /**
   * The broadcast’s title. The title may contain a maximum of 140
   * characters.
   */
  title?: string,
  /**
   * The length of time, in minutes, that the broadcast is scheduled to run.
   * The duration must be in the range 30 through 1380 (23 hours).
   */
  duration?: string,
  /**
   * The time zone where the broadcast takes place. Specify the time zone using
   * [IANA time zone database](https://www.iana.org/time-zones) format (for
   * example, America/New\_York).
   */
  timezone?: string,
  /**
   * The ID of the category that best represents the broadcast’s content. To
   * get the category ID, use the [Search
   * Categories](https://dev.twitch.tv/docs/api/reference#search-categories)
   * endpoint.
   */
  categoryId?: string,
  /**
   * A Boolean value that indicates whether the broadcast is canceled. Set to
   * **true** to cancel the segment.  
   *   
   * **NOTE**: For recurring segments, the API cancels the first segment after
   * the current UTC date and time and not the specified segment (unless the
   * specified segment is the next segment after the current UTC date and
   * time).
   */
  isCanceled?: boolean,
  /**
   * The ID of the broadcast segment to update.
   */
  id: string,
  /**
   * The date and time that the broadcast segment starts. Specify the date and
   * time in RFC3339 format (for example, 2022-08-02T06:00:00Z).  
   *   
   * **NOTE**: Only partners and affiliates may update a broadcast’s start
   * time and only for non-recurring segments.
   */
  startTime?: string,
}
export interface UpdateChannelStreamScheduleRequest {
  /**
   * The time zone that the broadcaster broadcasts from. Specify the time zone
   * using [IANA time zone database](https://www.iana.org/time-zones) format
   * (for example, America/New\_York). Required if _is\_vacation\_enabled_ is
   * **true**.
   */
  timezone?: string,
  /**
   * The UTC date and time of when the broadcaster’s vacation starts. Specify
   * the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z).
   * Required if _is\_vacation\_enabled_ is **true**.
   */
  vacationStartTime?: string,
  /**
   * A Boolean value that indicates whether the broadcaster has scheduled a
   * vacation. Set to **true** to enable Vacation Mode and add vacation dates,
   * or **false** to cancel a previously scheduled vacation.
   */
  isVacationEnabled?: boolean,
  /**
   * The UTC date and time of when the broadcaster’s vacation ends. Specify
   * the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z).
   * Required if _is\_vacation\_enabled_ is **true**.
   */
  vacationEndTime?: string,
}
export const GetChannelStreamScheduleResponse = z.object({
  /**
   * The broadcaster’s streaming schedule.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "pagination": z.object({
      /**
       * The cursor used to get the next page of results. Set the
       * request’s _after_ query parameter to this value.
       */
      "cursor": z.string().optional()
    }).optional(),
    "segments": z.object({
      "canceled_until": z.string(),
      "category": z.object({
        /**
         * An ID that identifies the category that best represents the
         * content that the broadcaster plans to stream. For example, the
         * game’s ID if the broadcaster will play a game or the Just
         * Chatting ID if the broadcaster will host a talk show.
         */
        "id": z.string(),
        /**
         * The name of the category. For example, the game’s title if
         * the broadcaster will play a game or Just Chatting if the
         * broadcaster will host a talk show.
         */
        "name": z.string()
      }),
      "end_time": z.string(),
      "id": z.string(),
      "is_recurring": z.boolean(),
      "start_time": z.string(),
      "title": z.string()
    }).transform((it) => ({
      /**
       * Indicates whether the broadcaster canceled this segment of a
       * recurring broadcast. If the broadcaster canceled this segment,
       * this field is set to the same value that’s in the `end_time`
       * field; otherwise, it’s set to **null**.
       */
      "canceledUntil": it["canceled_until"],
      /**
       * The type of content that the broadcaster plans to stream or
       * **null** if not specified.
       */
      "category": it["category"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * ends.
       */
      "endTime": it["end_time"],
      /**
       * An ID that identifies this broadcast segment.
       */
      "id": it["id"],
      /**
       * A Boolean value that determines whether the broadcast is part of
       * a recurring series that streams at the same time each week or is
       * a one-time broadcast. Is **true** if the broadcast is part of a
       * recurring series.
       */
      "isRecurring": it["is_recurring"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * starts.
       */
      "startTime": it["start_time"],
      /**
       * The broadcast segment’s title.
       */
      "title": it["title"],

    })).array(),
    "vacation": z.object({
      "end_time": z.string(),
      "start_time": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation ends.
       */
      "endTime": it["end_time"],
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation starts.
       */
      "startTime": it["start_time"],

    }))
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that owns the broadcast schedule.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The information used to page through a list of results. The object
     * is empty if there are no more pages left to page through. [Read
     * more](https://dev.twitch.tv/docs/api/guide#pagination).
     */
    "pagination": it["pagination"],
    /**
     * The list of broadcasts in the broadcaster’s streaming schedule.
     */
    "segments": it["segments"],
    /**
     * The dates when the broadcaster is on vacation and not streaming. Is
     * set to **null** if vacation mode is not enabled.
     */
    "vacation": it["vacation"],

  }))
});
export interface GetChannelStreamScheduleResponse extends z.infer<typeof GetChannelStreamScheduleResponse> {}

export const CreateChannelStreamScheduleSegmentResponse = z.object({
  /**
   * The broadcaster’s streaming scheduled.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "segments": z.object({
      "canceled_until": z.string(),
      "category": z.object({
        /**
         * An ID that identifies the category that best represents the
         * content that the broadcaster plans to stream. For example, the
         * game’s ID if the broadcaster will play a game or the Just
         * Chatting ID if the broadcaster will host a talk show.
         */
        "id": z.string(),
        /**
         * The name of the category. For example, the game’s title if
         * the broadcaster will play a game or Just Chatting if the
         * broadcaster will host a talk show.
         */
        "name": z.string()
      }),
      "end_time": z.string(),
      "id": z.string(),
      "is_recurring": z.boolean(),
      "start_time": z.string(),
      "title": z.string()
    }).transform((it) => ({
      /**
       * Indicates whether the broadcaster canceled this segment of a
       * recurring broadcast. If the broadcaster canceled this segment,
       * this field is set to the same value that’s in the `end_time`
       * field; otherwise, it’s set to **null**.
       */
      "canceledUntil": it["canceled_until"],
      /**
       * The type of content that the broadcaster plans to stream or
       * **null** if not specified.
       */
      "category": it["category"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * ends.
       */
      "endTime": it["end_time"],
      /**
       * An ID that identifies this broadcast segment.
       */
      "id": it["id"],
      /**
       * A Boolean value that determines whether the broadcast is part of
       * a recurring series that streams at the same time each week or is
       * a one-time broadcast. Is **true** if the broadcast is part of a
       * recurring series.
       */
      "isRecurring": it["is_recurring"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * starts.
       */
      "startTime": it["start_time"],
      /**
       * The broadcast segment’s title.
       */
      "title": it["title"],

    })).array(),
    "vacation": z.object({
      "end_time": z.string(),
      "start_time": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation ends.
       */
      "endTime": it["end_time"],
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation starts.
       */
      "startTime": it["start_time"],

    }))
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that owns the broadcast schedule.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * A list that contains the single broadcast segment that you added.
     */
    "segments": it["segments"],
    /**
     * The dates when the broadcaster is on vacation and not streaming. Is
     * set to **null** if vacation mode is not enabled.
     */
    "vacation": it["vacation"],

  }))
});
export interface CreateChannelStreamScheduleSegmentResponse extends z.infer<typeof CreateChannelStreamScheduleSegmentResponse> {}

export const UpdateChannelStreamScheduleSegmentResponse = z.object({
  /**
   * The broadcaster’s streaming scheduled.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "segments": z.object({
      "canceled_until": z.string(),
      "category": z.object({
        /**
         * An ID that identifies the category that best represents the
         * content that the broadcaster plans to stream. For example, the
         * game’s ID if the broadcaster will play a game or the Just
         * Chatting ID if the broadcaster will host a talk show.
         */
        "id": z.string(),
        /**
         * The name of the category. For example, the game’s title if
         * the broadcaster will play a game or Just Chatting if the
         * broadcaster will host a talk show.
         */
        "name": z.string()
      }),
      "end_time": z.string(),
      "id": z.string(),
      "is_recurring": z.boolean(),
      "start_time": z.string(),
      "title": z.string()
    }).transform((it) => ({
      /**
       * Indicates whether the broadcaster canceled this segment of a
       * recurring broadcast. If the broadcaster canceled this segment,
       * this field is set to the same value that’s in the `end_time`
       * field; otherwise, it’s set to **null**.
       */
      "canceledUntil": it["canceled_until"],
      /**
       * The type of content that the broadcaster plans to stream or
       * **null** if not specified.
       */
      "category": it["category"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * ends.
       */
      "endTime": it["end_time"],
      /**
       * An ID that identifies this broadcast segment.
       */
      "id": it["id"],
      /**
       * A Boolean value that determines whether the broadcast is part of
       * a recurring series that streams at the same time each week or is
       * a one-time broadcast. Is **true** if the broadcast is part of a
       * recurring series.
       */
      "isRecurring": it["is_recurring"],
      /**
       * The UTC date and time (in RFC3339 format) of when the broadcast
       * starts.
       */
      "startTime": it["start_time"],
      /**
       * The broadcast segment’s title.
       */
      "title": it["title"],

    })).array(),
    "vacation": z.object({
      "end_time": z.string(),
      "start_time": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation ends.
       */
      "endTime": it["end_time"],
      /**
       * The UTC date and time (in RFC3339 format) of when the
       * broadcaster’s vacation starts.
       */
      "startTime": it["start_time"],

    }))
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that owns the broadcast schedule.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * A list that contains the single broadcast segment that you updated.
     */
    "segments": it["segments"],
    /**
     * The dates when the broadcaster is on vacation and not streaming. Is
     * set to **null** if vacation mode is not enabled.
     */
    "vacation": it["vacation"],

  }))
});
export interface UpdateChannelStreamScheduleSegmentResponse extends z.infer<typeof UpdateChannelStreamScheduleSegmentResponse> {}



export class Schedule {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets the broadcaster’s streaming schedule. You can get the entire
   * schedule or specific segments of the schedule. [Learn
   * More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getChannelStreamSchedule(options: GetChannelStreamScheduleRequest): Promise<GetChannelStreamScheduleResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.utcOffset) {
      url.searchParams.append("utc_offset", options.utcOffset.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.id) {
      for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    }
    if (options.startTime) {
      url.searchParams.append("start_time", options.startTime.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelStreamScheduleResponse);
  }
  /**
   * Gets the broadcaster’s streaming schedule as an
   * [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).
   * 
   * __Authorization:__
   * 
   * The Client-Id and Authorization headers are not required.
   * 
   * __Response Body:__
   * 
   * The response body contains the iCalendar data (see
   * [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).
   * 
   * The Content-Type response header is set to `text/calendar`.
   */
  async getChannelIcalendar(options: GetChannelIcalendarRequest): Promise<Response> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule/icalendar", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.requestDownload(url, opts);
  }
  /**
   * Adds a single or recurring broadcast to the broadcaster’s streaming
   * schedule. For information about scheduling broadcasts, see [Stream
   * Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:schedule** scope.
   */
  async createChannelStreamScheduleSegment(options: CreateChannelStreamScheduleSegmentRequest): Promise<CreateChannelStreamScheduleSegmentResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule/segment", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.category_id = options.categoryId;
    body.start_time = options.startTime;
    body.title = options.title;
    body.duration = options.duration;
    body.is_recurring = options.isRecurring;
    body.timezone = options.timezone;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, CreateChannelStreamScheduleSegmentResponse);
  }
  /**
   * Removes a broadcast segment from the broadcaster’s streaming schedule.
   * 
   * **NOTE**: For recurring segments, removing a segment removes all segments
   * in the recurring schedule.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:schedule** scope.
   */
  async deleteChannelStreamScheduleSegment(options: DeleteChannelStreamScheduleSegmentRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule/segment", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    url.searchParams.append("id", options.id.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Updates a scheduled broadcast segment.
   * 
   * For recurring segments, updating a segment’s title, category, duration,
   * and timezone, changes all segments in the recurring schedule, not just the
   * specified segment.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:schedule** scope.
   */
  async updateChannelStreamScheduleSegment(options: UpdateChannelStreamScheduleSegmentRequest): Promise<UpdateChannelStreamScheduleSegmentResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule/segment", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    url.searchParams.append("id", options.id.toString());
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.title = options.title;
    body.duration = options.duration;
    body.timezone = options.timezone;
    body.category_id = options.categoryId;
    body.is_canceled = options.isCanceled;
    body.start_time = options.startTime;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateChannelStreamScheduleSegmentResponse);
  }
  /**
   * Updates the broadcaster’s schedule settings, such as scheduling a
   * vacation.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:schedule** scope.
   */
  async updateChannelStreamSchedule(options: UpdateChannelStreamScheduleRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/schedule/settings", this.#twitch.base);
    if (options.timezone) {
      url.searchParams.append("timezone", options.timezone.toString());
    }
    url.searchParams.append("broadcaster_id", snapshot.userId);
    if (options.vacationStartTime) {
      url.searchParams.append("vacation_start_time", options.vacationStartTime.toString());
    }
    if (options.isVacationEnabled) {
      url.searchParams.append("is_vacation_enabled", options.isVacationEnabled.toString());
    }
    if (options.vacationEndTime) {
      url.searchParams.append("vacation_end_time", options.vacationEndTime.toString());
    }
    const opts: RequestInit = { method: 'PATCH' };

    await this.#twitch.request(url, opts);
  }
}
