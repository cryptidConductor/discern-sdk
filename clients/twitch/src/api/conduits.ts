
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface CreateConduitsRequest {
  /**
   * The number of shards to create for this conduit.
   */
  shardCount: number,
}
export interface DeleteConduitRequest {
  /**
   * Conduit ID.
   */
  id: string,
}
export interface UpdateConduitsRequest {
  /**
   * The new number of shards for this conduit.
   */
  shardCount: number,
  /**
   * Conduit ID.
   */
  id: string,
}
export interface GetConduitShardsRequest {
  /**
   * Conduit ID.
   */
  conduitId: string,
  /**
   * Status to filter by.
   */
  status?: string,
  /**
   * The cursor used to get the next page of results. The pagination object in
   * the response contains the cursor’s value.
   */
  after?: string,
}
export interface UpdateConduitShardsRequest {
  /**
   * Conduit ID.
   */
  conduitId: string,
  /**
   * List of shards to update.
   */
  shards: {
  /**
   * Shard ID.
   */
  id: string,
  /**
   * The transport details that you want Twitch to use when sending you
   * notifications.
   */
  transport: {
    /**
     * The callback URL where the notifications are sent. The URL must use
     * the HTTPS protocol and port 443\. See Processing an event.Specify
     * this field only if method is set to webhook.NOTE: Redirects are not
     * followed.
     */
    callback?: string,
    /**
     * The transport method. Possible values are:  
     *   
     * * webhook
     * * websocket
     */
    method?: | "webhook"| "websocket",
    /**
     * The secret used to verify the signature. The secret must be an
     * ASCII string that’s a minimum of 10 characters long and a maximum
     * of 100 characters long. For information about how the secret is
     * used, see Verifying the event message.Specify this field only if
     * method is set to webhook.
     */
    secret?: string,
    /**
     * An ID that identifies the WebSocket to send notifications to. When
     * you connect to EventSub using WebSockets, the server returns the ID
     * in the Welcome message.Specify this field only if method is set to
     * websocket.
     */
    sessionId?: string
  }
}[],
}
export const GetConduitsResponse = z.object({
  /**
   * List of information about the client’s conduits.
   */
  "data": z.object({
    "id": z.string(),
    "shard_count": z.number()
  }).transform((it) => ({
    /**
     * Conduit ID.
     */
    "id": it["id"],
    /**
     * Number of shards associated with this conduit.
     */
    "shardCount": it["shard_count"],

  })).array()
});
export interface GetConduitsResponse extends z.infer<typeof GetConduitsResponse> {}

export const CreateConduitsResponse = z.object({
  /**
   * List of information about the client’s conduits.
   */
  "data": z.object({
    "id": z.string(),
    "shard_count": z.number()
  }).transform((it) => ({
    /**
     * Conduit ID.
     */
    "id": it["id"],
    /**
     * Number of shards created for this conduit.
     */
    "shardCount": it["shard_count"],

  })).array()
});
export interface CreateConduitsResponse extends z.infer<typeof CreateConduitsResponse> {}

export const UpdateConduitsResponse = z.object({
  /**
   * List of information about the client’s conduits.
   */
  "data": z.object({
    "id": z.string(),
    "shard_count": z.number()
  }).transform((it) => ({
    /**
     * Conduit ID.
     */
    "id": it["id"],
    /**
     * Number of shards associated with this conduit after the update.
     */
    "shardCount": it["shard_count"],

  })).array()
});
export interface UpdateConduitsResponse extends z.infer<typeof UpdateConduitsResponse> {}

export const GetConduitShardsResponse = z.object({
  /**
   * List of information about a conduit's shards.
   */
  "data": z.object({
    /**
     * Shard ID.
     */
    "id": z.string(),
    /**
     * The shard status. The subscriber receives events only for enabled
     * shards. Possible values are:  
     *   
     * * enabled — The shard is enabled.
     * * webhook\_callback\_verification\_pending — The shard is pending
     * verification of the specified callback URL.
     * * webhook\_callback\_verification\_failed — The specified
     * callback URL failed verification.
     * * notification\_failures\_exceeded — The notification delivery
     * failure rate was too high.
     * * websocket\_disconnected — The client closed the connection.
     * * websocket\_failed\_ping\_pong — The client failed to respond to
     * a ping message.
     * * websocket\_received\_inbound\_traffic — The client sent a
     * non-pong message. Clients may only send pong messages (and only in
     * response to a ping message).
     * * websocket\_internal\_error — The Twitch WebSocket server
     * experienced an unexpected error.
     * * websocket\_network\_timeout — The Twitch WebSocket server timed
     * out writing the message to the client.
     * * websocket\_network\_error — The Twitch WebSocket server
     * experienced a network error writing the message to the client.
     * * websocket\_failed\_to\_reconnect - The client failed to reconnect
     * to the Twitch WebSocket server within the required time after a
     * Reconnect Message.
     */
    "status": z.enum(["enabled", "webhook_callback_verification_pending", "webhook_callback_verification_failed", "notification_failures_exceeded", "websocket_disconnected", "websocket_failed_ping_pong", "websocket_received_inbound_traffic", "websocket_internal_error", "websocket_network_timeout", "websocket_network_error", "websocket_failed_to_reconnect"]),
    /**
     * The transport details used to send the notifications.
     */
    "transport": z.object({
      "callback": z.string().optional(),
      "connected_at": z.string().optional(),
      "disconnected_at": z.string().optional(),
      "method": z.enum(["webhook", "websocket"]),
      "session_id": z.string().optional()
    }).transform((it) => ({
      /**
       * The callback URL where the notifications are sent. Included only
       * if method is set to webhook.
       */
      "callback": it["callback"],
      /**
       * The UTC date and time that the WebSocket connection was
       * established. Included only if method is set to websocket.
       */
      "connectedAt": it["connected_at"],
      /**
       * The UTC date and time that the WebSocket connection was lost.
       * Included only if method is set to websocket.
       */
      "disconnectedAt": it["disconnected_at"],
      /**
       * The transport method. Possible values are:  
       *   
       * * webhook
       * * websocket
       */
      "method": it["method"],
      /**
       * An ID that identifies the WebSocket that notifications are sent
       * to. Included only if method is set to websocket.
       */
      "sessionId": it["session_id"],

    }))
  }).array(),
  /**
   * Contains information used to page through a list of results. The
   * object is empty if there are no more pages left to page through.
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s after query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetConduitShardsResponse extends z.infer<typeof GetConduitShardsResponse> {}



export class Conduits {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * NEW Gets the
   * [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events)
   * for a client ID.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async getConduits(): Promise<GetConduitsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits", this.#twitch.base);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetConduitsResponse);
  }
  /**
   * NEW Creates a new
   * [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async createConduits(options: CreateConduitsRequest): Promise<CreateConduitsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.shard_count = options.shardCount;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, CreateConduitsResponse);
  }
  /**
   * NEW Deletes a specified
   * [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).
   * Note that it may take some time for Eventsub subscriptions on a deleted
   * [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events) to
   * show as disabled when calling [Get Eventsub
   * Subscriptions](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async deleteConduit(options: DeleteConduitRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits", this.#twitch.base);
    url.searchParams.append("id", options.id.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * NEW Updates a
   * [conduit’s](https://dev.twitch.tv/docs/eventsub/handling-conduit-events)
   * shard count. To delete shards, update the count to a lower number, and the
   * shards above the count will be deleted. For example, if the existing shard
   * count is 100, by resetting shard count to 50, shards 50-99 are disabled.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async updateConduits(options: UpdateConduitsRequest): Promise<UpdateConduitsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits", this.#twitch.base);
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.shard_count = options.shardCount;
    body.id = options.id;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateConduitsResponse);
  }
  /**
   * NEW Gets a lists of all shards for a
   * [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async getConduitShards(options: GetConduitShardsRequest): Promise<GetConduitShardsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits/shards", this.#twitch.base);
    url.searchParams.append("conduit_id", options.conduitId.toString());
    if (options.status) {
      url.searchParams.append("status", options.status.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetConduitShardsResponse);
  }
  /**
   * NEW Updates shard(s) for a
   * [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events).
   * 
   * **NOTE:** Shard IDs are indexed starting at 0, so a conduit with a
   * `shard_count` of 5 will have shards with IDs 0 through 4.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async updateConduitShards(options: UpdateConduitShardsRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/eventsub/conduits/shards", this.#twitch.base);
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.conduit_id = options.conduitId;
    body.shards = options.shards;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
}
