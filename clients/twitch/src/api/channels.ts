
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetChannelInformationRequest {
  /**
   * The ID of the broadcaster whose channel you want to get. To specify more
   * than one ID, include this parameter for each broadcaster you want to get.
   * For example, `broadcaster_id=1234&broadcaster_id=5678`. You may specify a
   * maximum of 100 IDs. The API ignores duplicate IDs and IDs that are not
   * found.
   */
  broadcasterId: string[],
}
export interface ModifyChannelInformationRequest {
  /**
   * Boolean flag indicating if the channel has branded content.
   */
  isBrandedContent?: boolean,
  /**
   * The user’s preferred language. Set the value to an ISO 639-1 two-letter
   * language code (for example, _en_ for English). Set to “other” if the
   * user’s preferred language is not a Twitch supported language. The
   * language isn’t updated if the language code isn’t a Twitch supported
   * language.
   */
  broadcasterLanguage?: string,
  /**
   * The number of seconds you want your broadcast buffered before streaming it
   * live. The delay helps ensure fairness during competitive play. Only users
   * with Partner status may set this field. The maximum delay is 900 seconds
   * (15 minutes).
   */
  delay?: number,
  /**
   * The title of the user’s stream. You may not set this field to an empty
   * string.
   */
  title?: string,
  /**
   * A list of channel-defined tags to apply to the channel. To remove all tags
   * from the channel, set tags to an empty array. Tags help identify the
   * content that the channel streams. [Learn
   * More](https://help.twitch.tv/s/article/guide-to-tags)  
   *   
   * A channel may specify a maximum of 10 tags. Each tag is limited to a
   * maximum of 25 characters and may not be an empty string or contain spaces
   * or special characters. Tags are case insensitive. For readability,
   * consider using camelCasing or PascalCasing.
   */
  tags?: string[],
  /**
   * The ID of the game that the user plays. The game is not updated if the ID
   * isn’t a game ID that Twitch recognizes. To unset this field, use “0”
   * or “” (an empty string).
   */
  gameId?: string,
  /**
   * List of labels that should be set as the Channel’s CCLs.
   */
  contentClassificationLabels?: {
  /**
   * ID of the [Content Classification
   * Labels](https://blog.twitch.tv/en/2023/06/20/introducing-content-classification-labels/) 
   * that must be added/removed from the channel. Can be one of the
   * following values:
   *   
   * * DrugsIntoxication
   * * SexualThemes
   * * ViolentGraphic
   * * Gambling
   * * ProfanityVulgarity
   */
  id: | "DrugsIntoxication"| "SexualThemes"| "ViolentGraphic"| "Gambling"| "ProfanityVulgarity",
  /**
   * Boolean flag indicating whether the label should be enabled (true) or
   * disabled for the channel.
   */
  isEnabled: boolean
}[],
}
export interface GetFollowedChannelsRequest {
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100\. The default
   * is 20.
   */
  first?: number,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * more](https://dev.twitch.tv/docs/api/guide#pagination).
   */
  after?: string,
  /**
   * A broadcaster’s ID. Use this parameter to see whether the user follows
   * this broadcaster. If specified, the response contains this broadcaster if
   * the user follows them. If not specified, the response contains all
   * broadcasters that the user follows.
   */
  broadcasterId?: string,
  /**
   * A user’s ID. Returns the list of broadcasters that this user follows.
   * This ID must match the user ID in the user OAuth token.
   */
  userId: string,
}
export interface GetChannelFollowersRequest {
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * more](https://dev.twitch.tv/docs/api/guide#pagination).
   */
  after?: string,
  /**
   * The broadcaster’s ID. Returns the list of users that follow this
   * broadcaster.
   */
  broadcasterId: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100\. The default
   * is 20.
   */
  first?: number,
}
export const GetChannelInformationResponse = z.object({
  /**
   * A list that contains information about the specified channels. The
   * list is empty if the specified channels weren’t found.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_language": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "content_classification_labels": z.string().array(),
    "delay": z.number(),
    "game_id": z.string(),
    "game_name": z.string(),
    "is_branded_content": z.boolean(),
    "tags": z.string().array(),
    "title": z.string()
  }).transform((it) => ({
    /**
     * An ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s preferred language. The value is an ISO 639-1
     * two-letter language code (for example, _en_ for English). The value
     * is set to “other” if the language is not a Twitch supported
     * language.
     */
    "broadcasterLanguage": it["broadcaster_language"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The CCLs applied to the channel.
     */
    "contentClassificationLabels": it["content_classification_labels"],
    /**
     * The value of the broadcaster’s stream delay setting, in seconds.
     * This field’s value defaults to zero unless 1) the request
     * specifies a user access token, 2) the ID in the _broadcaster\_id_
     * query parameter matches the user ID in the access token, and 3) the
     * broadcaster has partner status and they set a non-zero stream delay
     * value.
     */
    "delay": it["delay"],
    /**
     * An ID that uniquely identifies the game that the broadcaster is
     * playing or last played. The value is an empty string if the
     * broadcaster has never played a game.
     */
    "gameId": it["game_id"],
    /**
     * The name of the game that the broadcaster is playing or last
     * played. The value is an empty string if the broadcaster has never
     * played a game.
     */
    "gameName": it["game_name"],
    /**
     * Boolean flag indicating if the channel has branded content.
     */
    "isBrandedContent": it["is_branded_content"],
    /**
     * The tags applied to the channel.
     */
    "tags": it["tags"],
    /**
     * The title of the stream that the broadcaster is currently streaming
     * or last streamed. The value is an empty string if the broadcaster
     * has never streamed.
     */
    "title": it["title"],

  })).array()
});
export interface GetChannelInformationResponse extends z.infer<typeof GetChannelInformationResponse> {}

export const GetChannelEditorsResponse = z.object({
  /**
   * A list of users that are editors for the specified broadcaster. The
   * list is empty if the broadcaster doesn’t have editors.
   */
  "data": z.object({
    "created_at": z.string(),
    "user_id": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The date and time, in RFC3339 format, when the user became one of
     * the broadcaster’s editors.
     */
    "createdAt": it["created_at"],
    /**
     * An ID that uniquely identifies a user with editor permissions.
     */
    "userId": it["user_id"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array()
});
export interface GetChannelEditorsResponse extends z.infer<typeof GetChannelEditorsResponse> {}

export const GetFollowedChannelsResponse = z.object({
  /**
   * The list of broadcasters that the user follows. The list is in
   * descending order by `followed_at` (with the most recently followed
   * broadcaster first). The list is empty if the user doesn’t follow
   * anyone.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "followed_at": z.string()
  }).transform((it) => ({
    /**
     * An ID that uniquely identifies the broadcaster that this user is
     * following.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The UTC timestamp when the user started following the broadcaster.
     */
    "followedAt": it["followed_at"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional(),
  /**
   * The total number of broadcasters that the user follows. As someone
   * pages through the list, the number may change as the user follows or
   * unfollows broadcasters.
   */
  "total": z.number()
});
export interface GetFollowedChannelsResponse extends z.infer<typeof GetFollowedChannelsResponse> {}

export const GetChannelFollowersResponse = z.object({
  /**
   * The list of users that follow the specified broadcaster. The list is
   * in descending order by `followed_at` (with the most recent follower
   * first). The list is empty if nobody follows the broadcaster, the
   * specified `user_id` isn’t in the follower list, the user access
   * token is missing the **moderator:read:followers** scope, or the user
   * isn’t the broadcaster or moderator for the channel.
   */
  "data": z.object({
    "followed_at": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The UTC timestamp when the user started following the broadcaster.
     */
    "followedAt": it["followed_at"],
    /**
     * An ID that uniquely identifies the user that’s following the
     * broadcaster.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional(),
  /**
   * The total number of users that follow this broadcaster. As someone
   * pages through the list, the number of users may change as users
   * follow or unfollow the broadcaster.
   */
  "total": z.number()
});
export interface GetChannelFollowersResponse extends z.infer<typeof GetChannelFollowersResponse> {}



export class Channels {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets information about one or more channels.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getChannelInformation(options: GetChannelInformationRequest): Promise<GetChannelInformationResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels", this.#twitch.base);
    for (const value of options.broadcasterId) {
      url.searchParams.append("broadcaster_id", value.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelInformationResponse);
  }
  /**
   * Updates a channel’s properties.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:broadcast** scope.
   * 
   * __Request Body:__
   * 
   * All fields are optional, but you must specify at least one field.
   */
  async modifyChannelInformation(options: ModifyChannelInformationRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.is_branded_content = options.isBrandedContent;
    body.broadcaster_language = options.broadcasterLanguage;
    body.delay = options.delay;
    body.title = options.title;
    body.tags = options.tags;
    body.game_id = options.gameId;
    body.content_classification_labels = options.contentClassificationLabels;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s list editors.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:editors** scope.
   */
  async getChannelEditors(): Promise<GetChannelEditorsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/editors", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelEditorsResponse);
  }
  /**
   * Gets a list of broadcasters that the specified user follows. You can also
   * use this endpoint to see whether a user follows a specific broadcaster.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:follows** scope.
   */
  async getFollowedChannels(options: GetFollowedChannelsRequest): Promise<GetFollowedChannelsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/followed", this.#twitch.base);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.broadcasterId) {
      url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    }
    url.searchParams.append("user_id", options.userId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetFollowedChannelsResponse);
  }
  /**
   * Gets a list of users that follow the specified broadcaster. You can also
   * use this endpoint to see whether a specific user follows the broadcaster.
   * 
   * __Authorization:__
   * 
   * * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:read:followers** scope.
   * * The ID in the broadcaster\_id query parameter must match the user ID in
   * the access token or the user ID in the access token must be a moderator
   * for the specified broadcaster.
   * 
   * This endpoint will return specific follower information only if both of
   * the above are true. If a scope is not provided or the user isn’t the
   * broadcaster or a moderator for the specified channel, only the total
   * follower count will be included in the response.
   */
  async getChannelFollowers(options: GetChannelFollowersRequest): Promise<GetChannelFollowersResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/followers", this.#twitch.base);
    url.searchParams.append("user_id", snapshot.userId);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelFollowersResponse);
  }
}
