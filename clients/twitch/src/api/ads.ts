
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetAdScheduleRequest {
  /**
   * Provided `broadcaster_id` must match the `user_id` in the auth token.
   */
  broadcasterId: string,
}
export interface SnoozeNextAdRequest {
  /**
   * Provided `broadcaster_id` must match the `user_id` in the auth token.
   */
  broadcasterId: string,
}
export interface StartCommercialRequest {
  /**
   * The length of the commercial to run, in seconds. Twitch tries to serve a
   * commercial that’s the requested length, but it may be shorter or longer.
   * The maximum length you should request is 180 seconds.
   */
  length: number,
  /**
   * The ID of the partner or affiliate broadcaster that wants to run the
   * commercial. This ID must match the user ID found in the OAuth token.
   */
  broadcasterId: string,
}
export const GetAdScheduleResponse = z.object({
  /**
   * A list that contains information related to the channel’s ad
   * schedule.
   */
  "data": z.object({
    "duration": z.number(),
    "last_ad_at": z.string(),
    "next_ad_at": z.string(),
    "preroll_free_time": z.number(),
    "snooze_count": z.number(),
    "snooze_refresh_at": z.string()
  }).transform((it) => ({
    /**
     * The length in seconds of the scheduled upcoming ad break.
     */
    "duration": it["duration"],
    /**
     * The UTC timestamp of the broadcaster’s last ad-break, in RFC3339
     * format. Empty if the channel has not run an ad or is not live.
     */
    "lastAdAt": it["last_ad_at"],
    /**
     * The UTC timestamp of the broadcaster’s next scheduled ad, in
     * RFC3339 format. Empty if the channel has no ad scheduled or is not
     * live.
     */
    "nextAdAt": it["next_ad_at"],
    /**
     * The amount of pre-roll free time remaining for the channel in
     * seconds. Returns 0 if they are currently not pre-roll free.
     */
    "prerollFreeTime": it["preroll_free_time"],
    /**
     * The number of snoozes available for the broadcaster.
     */
    "snoozeCount": it["snooze_count"],
    /**
     * The UTC timestamp when the broadcaster will gain an additional
     * snooze, in RFC3339 format.
     */
    "snoozeRefreshAt": it["snooze_refresh_at"],

  })).array()
});
export interface GetAdScheduleResponse extends z.infer<typeof GetAdScheduleResponse> {}

export const SnoozeNextAdResponse = z.object({
  /**
   * A list that contains information about the channel’s snoozes and
   * next upcoming ad after successfully snoozing.
   */
  "data": z.object({
    "next_ad_at": z.string(),
    "snooze_count": z.number(),
    "snooze_refresh_at": z.string()
  }).transform((it) => ({
    /**
     * The UTC timestamp of the broadcaster’s next scheduled ad, in
     * RFC3339 format.
     */
    "nextAdAt": it["next_ad_at"],
    /**
     * The number of snoozes available for the broadcaster.
     */
    "snoozeCount": it["snooze_count"],
    /**
     * The UTC timestamp when the broadcaster will gain an additional
     * snooze, in RFC3339 format.
     */
    "snoozeRefreshAt": it["snooze_refresh_at"],

  })).array()
});
export interface SnoozeNextAdResponse extends z.infer<typeof SnoozeNextAdResponse> {}

export const StartCommercialResponse = z.object({
  /**
   * An array that contains a single object with the status of your start
   * commercial request.
   */
  "data": z.object({
    "length": z.number(),
    "message": z.string(),
    "retry_after": z.number()
  }).transform((it) => ({
    /**
     * The length of the commercial you requested. If you request a
     * commercial that’s longer than 180 seconds, the API uses 180
     * seconds.
     */
    "length": it["length"],
    /**
     * A message that indicates whether Twitch was able to serve an ad.
     */
    "message": it["message"],
    /**
     * The number of seconds you must wait before running another
     * commercial.
     */
    "retryAfter": it["retry_after"],

  })).array()
});
export interface StartCommercialResponse extends z.infer<typeof StartCommercialResponse> {}



export class Ads {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * This endpoint returns ad schedule related information, including snooze,
   * when the last ad was run, when the next ad is scheduled, and if the
   * channel is currently in pre-roll free time. Note that a new ad cannot be
   * run until 8 minutes after running a previous ad.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:ads** scope. The `user_id` in the user access
   * token must match the `broadcaster_id`.
   */
  async getAdSchedule(options: GetAdScheduleRequest): Promise<GetAdScheduleResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/ads", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetAdScheduleResponse);
  }
  /**
   * If available, pushes back the timestamp of the upcoming automatic mid-roll
   * ad by 5 minutes. This endpoint duplicates the snooze functionality in the
   * creator dashboard’s Ads Manager.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:ads** scope. The `user_id` in the user
   * access token must match the `broadcaster_id`.
   */
  async snoozeNextAd(options: SnoozeNextAdRequest): Promise<SnoozeNextAdResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/ads/schedule/snooze", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    return await this.#twitch.request(url, opts, SnoozeNextAdResponse);
  }
  /**
   * Starts a commercial on the specified channel.
   * 
   * **NOTE**: Only partners and affiliates may run commercials and they must
   * be streaming live at the time.
   * 
   * **NOTE**: Only the broadcaster may start a commercial; the broadcaster’s
   * editors and moderators may not start commercials on behalf of the
   * broadcaster.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:edit:commercial** scope.
   */
  async startCommercial(options: StartCommercialRequest): Promise<StartCommercialResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/commercial", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.length = options.length;
    body.broadcaster_id = options.broadcasterId;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, StartCommercialResponse);
  }
}
