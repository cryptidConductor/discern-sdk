
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetStreamsRequest {
  /**
   * The type of stream to filter the list of streams by. Possible values are:
   * 
   *   
   * * all
   * * live
   *   
   * The default is _all_.
   */
  type?: | "all"| "live",
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: number,
  /**
   * A game (category) ID used to filter the list of streams. Returns only the
   * streams that are broadcasting the game (category). You may specify a
   * maximum of 100 IDs. To specify multiple IDs, include the _game\_id_
   * parameter for each game. For example, `&game_id=9876&game_id=5432`.
   */
  gameId?: string[],
  /**
   * A user ID used to filter the list of streams. Returns only the streams of
   * those users that are broadcasting. You may specify a maximum of 100 IDs.
   * To specify multiple IDs, include the _user\_id_ parameter for each user.
   * For example, `&user_id=1234&user_id=5678`.
   */
  userId?: string[],
  /**
   * A user login name used to filter the list of streams. Returns only the
   * streams of those users that are broadcasting. You may specify a maximum of
   * 100 login names. To specify multiple names, include the _user\_login_
   * parameter for each user. For example, `&user_login=foo&user_login=bar`.
   */
  userLogin?: string[],
  /**
   * The cursor used to get the previous page of results. The **Pagination**
   * object in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  before?: string,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * A language code used to filter the list of streams. Returns only streams
   * that broadcast in the specified language. Specify the language using an
   * ISO 639-1 two-letter language code or _other_ if the broadcast uses a
   * language not in the list of [supported stream
   * languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang). 
   * 
   *   
   * You may specify a maximum of 100 language codes. To specify multiple
   * languages, include the _language_ parameter for each language. For
   * example, `&language=de&language=fr`.
   */
  language?: string[],
}
export interface GetFollowedStreamsRequest {
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 100.
   */
  first?: number,
}
export interface GetStreamMarkersRequest {
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: string,
  /**
   * A video on demand (VOD)/video ID. The request returns the markers from
   * this VOD/video. The user in the access token must own the video or the
   * user must be one of the broadcaster’s editors.  
   *   
   * This parameter and the _user\_id_ query parameter are mutually exclusive.
   */
  videoId?: string,
  /**
   * The cursor used to get the previous page of results. The **Pagination**
   * object in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  before?: string,
}
export interface CreateStreamMarkerRequest {
  /**
   * A short description of the marker to help the user remember why they
   * marked the location. The maximum length of the description is 140
   * characters.
   */
  description?: string,
}
export const GetStreamsResponse = z.object({
  /**
   * The list of streams.
   */
  "data": z.object({
    "game_id": z.string(),
    "game_name": z.string(),
    "id": z.string(),
    "is_mature": z.boolean(),
    "language": z.string(),
    "started_at": z.string(),
    "tag_ids": z.string().array(),
    "tags": z.string().array(),
    "thumbnail_url": z.string(),
    "title": z.string(),
    "type": z.enum(["live"]),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string(),
    "viewer_count": z.number()
  }).transform((it) => ({
    /**
     * The ID of the category or game being played.
     */
    "gameId": it["game_id"],
    /**
     * The ID of the category or game being played.
     */
    "gameName": it["game_name"],
    /**
     * An ID that identifies the stream. You can use this ID later to look
     * up the video on demand (VOD).
     */
    "id": it["id"],
    /**
     * A Boolean value that indicates whether the stream is meant for
     * mature audiences.
     */
    "isMature": it["is_mature"],
    /**
     * The language that the stream uses. This is an ISO 639-1 two-letter
     * language code or _other_ if the stream uses a language not in the
     * list of [supported stream
     * languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
     */
    "language": it["language"],
    /**
     * The UTC date and time (in RFC3339 format) of when the broadcast
     * began.
     */
    "startedAt": it["started_at"],
    /**
     * **IMPORTANT** As of February 28, 2023, this field is deprecated and
     * returns only an empty array. If you use this field, please update
     * your code to use the `tags` field.  
     *   
     * The list of tags that apply to the stream. The list contains IDs
     * only when the channel is steaming live. For a list of possible
     * tags, see [List of All
     * Tags](https://www.twitch.tv/directory/all/tags). The list doesn’t
     * include Category Tags.
     */
    "tagIds": it["tag_ids"],
    /**
     * The tags applied to the stream.
     */
    "tags": it["tags"],
    /**
     * A URL to an image of a frame from the last 5 minutes of the stream.
     * Replace the width and height placeholders in the URL
     * (`{width}x{height}`) with the size of the image you want, in
     * pixels.
     */
    "thumbnailUrl": it["thumbnail_url"],
    /**
     * The stream’s title. Is an empty string if not set.
     */
    "title": it["title"],
    /**
     * The type of stream. Possible values are:  
     *   
     * * live
     *   
     * If an error occurs, this field is set to an empty string.
     */
    "type": it["type"],
    /**
     * The ID of the user that’s broadcasting the stream.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],
    /**
     * The number of users watching the stream.
     */
    "viewerCount": it["viewer_count"],

  })).array(),
  /**
   * The information used to page through the list of results. The object
   * is empty if there are no more pages left to page through. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Set the
     * request’s _after_ or _before_ query parameter to this value
     * depending on whether you’re paging forwards or backwards.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetStreamsResponse extends z.infer<typeof GetStreamsResponse> {}

export const GetFollowedStreamsResponse = z.object({
  /**
   * The list of live streams of broadcasters that the specified user
   * follows. The list is in descending order by the number of viewers
   * watching the stream. Because viewers come and go during a stream,
   * it’s possible to find duplicate or missing streams in the list as
   * you page through the results. The list is empty if none of the
   * followed broadcasters are streaming live.
   */
  "data": z.object({
    "game_id": z.string(),
    "game_name": z.string(),
    "id": z.string(),
    "is_mature": z.boolean(),
    "language": z.string(),
    "started_at": z.string(),
    "tag_ids": z.string().array(),
    "tags": z.string().array(),
    "thumbnail_url": z.string(),
    "title": z.string(),
    "type": z.enum(["live"]),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string(),
    "viewer_count": z.number()
  }).transform((it) => ({
    /**
     * The ID of the category or game being played.
     */
    "gameId": it["game_id"],
    /**
     * The ID of the category or game being played.
     */
    "gameName": it["game_name"],
    /**
     * An ID that identifies the stream. You can use this ID later to look
     * up the video on demand (VOD).
     */
    "id": it["id"],
    /**
     * A Boolean value that indicates whether the stream is meant for
     * mature audiences.
     */
    "isMature": it["is_mature"],
    /**
     * The language that the stream uses. This is an ISO 639-1 two-letter
     * language code or _other_ if the stream uses a language not in the
     * list of [supported stream
     * languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
     */
    "language": it["language"],
    /**
     * The UTC date and time (in RFC3339 format) of when the broadcast
     * began.
     */
    "startedAt": it["started_at"],
    /**
     * **IMPORTANT** As of February 28, 2023, this field is deprecated and
     * returns only an empty array. If you use this field, please update
     * your code to use the `tags` field.  
     *   
     * The list of tags that apply to the stream. The list contains IDs
     * only when the channel is steaming live. For a list of possible
     * tags, see [List of All
     * Tags](https://www.twitch.tv/directory/all/tags). The list doesn’t
     * include Category Tags.
     */
    "tagIds": it["tag_ids"],
    /**
     * The tags applied to the stream.
     */
    "tags": it["tags"],
    /**
     * A URL to an image of a frame from the last 5 minutes of the stream.
     * Replace the width and height placeholders in the URL
     * (`{width}x{height}`) with the size of the image you want, in
     * pixels.
     */
    "thumbnailUrl": it["thumbnail_url"],
    /**
     * The stream’s title. Is an empty string if not set.
     */
    "title": it["title"],
    /**
     * The type of stream. Possible values are:  
     *   
     * * live
     *   
     * If an error occurs, this field is set to an empty string.
     */
    "type": it["type"],
    /**
     * The ID of the user that’s broadcasting the stream.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],
    /**
     * The number of users watching the stream.
     */
    "viewerCount": it["viewer_count"],

  })).array(),
  /**
   * The information used to page through the list of results. The object
   * is empty if there are no more pages left to page through. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Set the
     * request’s _after_ query parameter to this value.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetFollowedStreamsResponse extends z.infer<typeof GetFollowedStreamsResponse> {}

export const GetStreamKeyResponse = z.object({
  /**
   * A list that contains the channel’s stream key.
   */
  "data": z.object({
    "stream_key": z.string()
  }).transform((it) => ({
    /**
     * The channel’s stream key.
     */
    "streamKey": it["stream_key"],

  })).array()
});
export interface GetStreamKeyResponse extends z.infer<typeof GetStreamKeyResponse> {}

export const GetStreamMarkersResponse = z.object({
  /**
   * The list of markers grouped by the user that created the marks.
   */
  "data": z.object({
    "markers": z.object({
      "created_at": z.string(),
      "description": z.string(),
      "id": z.string(),
      "position_seconds": z.number(),
      "url": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) of when the user
       * created the marker.
       */
      "createdAt": it["created_at"],
      /**
       * The description that the user gave the marker to help them
       * remember why they marked the location. Is an empty string if the
       * user didn’t provide one.
       */
      "description": it["description"],
      /**
       * An ID that identifies this marker.
       */
      "id": it["id"],
      /**
       * The relative offset (in seconds) of the marker from the beginning
       * of the stream.
       */
      "positionSeconds": it["position_seconds"],
      /**
       * A URL that opens the video in Twitch Highlighter.
       */
      "url": it["url"],

    })).array(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string(),
    "video_id": z.string(),
    "videos": z.object({}).array()
  }).transform((it) => ({
    /**
     * The list of markers in this video. The list in ascending order by
     * when the marker was created.
     */
    "markers": it["markers"],
    /**
     * The ID of the user that created the marker.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],
    /**
     * An ID that identifies this video.
     */
    "videoId": it["video_id"],
    /**
     * A list of videos that contain markers. The list contains a single
     * video.
     */
    "videos": it["videos"],

  })).array(),
  /**
   * The information used to page through the list of results. The object
   * is empty if there are no more pages left to page through. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Set the
     * request’s _after_ or _before_ query parameter to this value
     * depending on whether you’re paging forwards or backwards.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetStreamMarkersResponse extends z.infer<typeof GetStreamMarkersResponse> {}

export const CreateStreamMarkerResponse = z.object({
  /**
   * A list that contains the single marker that you added.
   */
  "data": z.object({
    "created_at": z.string(),
    "description": z.string(),
    "id": z.string(),
    "position_seconds": z.number()
  }).transform((it) => ({
    /**
     * The UTC date and time (in RFC3339 format) of when the user created
     * the marker.
     */
    "createdAt": it["created_at"],
    /**
     * A description that the user gave the marker to help them remember
     * why they marked the location.
     */
    "description": it["description"],
    /**
     * An ID that identifies this marker.
     */
    "id": it["id"],
    /**
     * The relative offset (in seconds) of the marker from the beginning
     * of the stream.
     */
    "positionSeconds": it["position_seconds"],

  })).array()
});
export interface CreateStreamMarkerResponse extends z.infer<typeof CreateStreamMarkerResponse> {}



export class Streams {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets a list of all streams. The list is in descending order by the number
   * of viewers watching the stream. Because viewers come and go during a
   * stream, it’s possible to find duplicate or missing streams in the list
   * as you page through the results.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getStreams(options: GetStreamsRequest): Promise<GetStreamsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/streams", this.#twitch.base);
    if (options.type) {
      url.searchParams.append("type", options.type.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.gameId) {
      for (const value of options.gameId) {
      url.searchParams.append("game_id", value.toString());
    }
    }
    if (options.userId) {
      for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    }
    if (options.userLogin) {
      for (const value of options.userLogin) {
      url.searchParams.append("user_login", value.toString());
    }
    }
    if (options.before) {
      url.searchParams.append("before", options.before.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.language) {
      for (const value of options.language) {
      url.searchParams.append("language", value.toString());
    }
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetStreamsResponse);
  }
  /**
   * Gets the list of broadcasters that the user follows and that are streaming
   * live.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:follows** scope.
   */
  async getFollowedStreams(options: GetFollowedStreamsRequest): Promise<GetFollowedStreamsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/streams/followed", this.#twitch.base);
    url.searchParams.append("user_id", snapshot.userId);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetFollowedStreamsResponse);
  }
  /**
   * Gets the channel’s stream key.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:stream\_key** scope.
   */
  async getStreamKey(): Promise<GetStreamKeyResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/streams/key", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetStreamKeyResponse);
  }
  /**
   * Gets a list of markers from the user’s most recent stream or from the
   * specified VOD/video. A marker is an arbitrary point in a live stream that
   * the broadcaster or editor marked, so they can return to that spot later to
   * create video highlights (see Video Producer, Highlights in the Twitch UX).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:broadcast** or **channel:manage:broadcast**
   * scope.
   */
  async getStreamMarkers(options: GetStreamMarkersRequest): Promise<GetStreamMarkersResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/streams/markers", this.#twitch.base);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.videoId) {
      url.searchParams.append("video_id", options.videoId.toString());
    }
    url.searchParams.append("user_id", snapshot.userId);
    if (options.before) {
      url.searchParams.append("before", options.before.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetStreamMarkersResponse);
  }
  /**
   * Adds a marker to a live stream. A marker is an arbitrary point in a live
   * stream that the broadcaster or editor wants to mark, so they can return to
   * that spot later to create video highlights (see Video Producer, Highlights
   * in the Twitch UX).
   * 
   * You may not add markers:
   * 
   * * If the stream is not live
   * * If the stream has not enabled video on demand (VOD)
   * * If the stream is a premiere (a live, first-viewing event that combines
   * uploaded videos with live chat)
   * * If the stream is a rerun of a past broadcast, including past premieres.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:broadcast** scope.
   */
  async createStreamMarker(options: CreateStreamMarkerRequest): Promise<CreateStreamMarkerResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/streams/markers", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.description = options.description;
    body.user_id = snapshot.userId;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, CreateStreamMarkerResponse);
  }
}
