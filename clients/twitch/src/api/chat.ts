
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface SendChatAnnouncementRequest {
  /**
   * The ID of the broadcaster that owns the chat room to send the announcement
   * to.
   */
  broadcasterId: string,
  /**
   * The color used to highlight the announcement. Possible case-sensitive
   * values are:  
   *   
   * * blue
   * * green
   * * orange
   * * purple
   * * primary (default)
   *   
   * If `color` is set to _primary_ or is not set, the channel’s accent color
   * is used to highlight the announcement (see **Profile Accent Color** under
   * [profile settings](https://www.twitch.tv/settings/profile), **Channel and
   * Videos**, and **Brand**).
   */
  color?: | "blue"| "green"| "orange"| "purple"| "primary (default)",
  /**
   * The announcement to make in the broadcaster’s chat room. Announcements
   * are limited to a maximum of 500 characters; announcements longer than 500
   * characters are truncated.
   */
  message: string,
}
export interface GetChannelChatBadgesRequest {
  /**
   * The ID of the broadcaster whose chat badges you want to get.
   */
  broadcasterId: string,
}
export interface GetChattersRequest {
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 1,000\. The
   * default is 100.
   */
  first?: number,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The ID of the broadcaster whose list of chatters you want to get.
   */
  broadcasterId: string,
}
export interface GetUserChatColorRequest {
  /**
   * The ID of the user whose username color you want to get. To specify more
   * than one user, include the _user\_id_ parameter for each user to get. For
   * example, `&user_id=1234&user_id=5678`. The maximum number of IDs that you
   * may specify is 100.  
   *   
   * The API ignores duplicate IDs and IDs that weren’t found.
   */
  userId: string[],
}
export interface UpdateUserChatColorRequest {
  /**
   * The color to use for the user's name in chat. All users may specify one of
   * the following named color values.  
   *   
   * * blue
   * * blue\_violet
   * * cadet\_blue
   * * chocolate
   * * coral
   * * dodger\_blue
   * * firebrick
   * * golden\_rod
   * * green
   * * hot\_pink
   * * orange\_red
   * * red
   * * sea\_green
   * * spring\_green
   * * yellow\_green
   *   
   * Turbo and Prime users may specify a named color or a Hex color code like
   * #9146FF. If you use a Hex color code, remember to URL encode it.
   */
  color: | "blue"| "blue_violet"| "cadet_blue"| "chocolate"| "coral"| "dodger_blue"| "firebrick"| "golden_rod"| "green"| "hot_pink"| "orange_red"| "red"| "sea_green"| "spring_green"| "yellow_green",
}
export interface GetChannelEmotesRequest {
  /**
   * An ID that identifies the broadcaster whose emotes you want to get.
   */
  broadcasterId: string,
}
export interface GetEmoteSetsRequest {
  /**
   * An ID that identifies the emote set to get. Include this parameter for
   * each emote set you want to get. For example,
   * `emote_set_id=1234&emote_set_id=5678`. You may specify a maximum of 25
   * IDs. The response contains only the IDs that were found and ignores
   * duplicate IDs.  
   *   
   * To get emote set IDs, use the [Get Channel
   * Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.
   */
  emoteSetId: string[],
}
export interface GetUserEmotesRequest {
  /**
   * The cursor used to get the next page of results. The Pagination object in
   * the response contains the cursor’s value.
   */
  after?: string,
  /**
   * The User ID of a broadcaster you wish to get follower emotes of. Using
   * this query parameter will guarantee inclusion of the broadcaster’s
   * follower emotes in the response body.   
   *   
   * **Note:** If the user specified in `user_id` is subscribed to the
   * broadcaster specified, their follower emotes will appear in the response
   * body regardless if this query parameter is used.
   */
  broadcasterId?: string,
}
export interface SendChatMessageRequest {
  /**
   * The ID of the chat message being replied to.
   */
  replyParentMessageId?: string,
  /**
   * The message to send. The message is limited to a maximum of 500
   * characters. Chat messages can also include emoticons. To include
   * emoticons, use the name of the emote. The names are case sensitive.
   * Don’t include colons around the name (e.g., :bleedPurple:). If Twitch
   * recognizes the name, Twitch converts the name to the emote before writing
   * the chat message to the chat room
   */
  message: string,
  /**
   * The ID of the broadcaster whose chat room the message will be sent to.
   */
  broadcasterId: string,
}
export interface GetChatSettingsRequest {
  /**
   * The ID of the broadcaster whose chat settings you want to get.
   */
  broadcasterId: string,
}
export interface UpdateChatSettingsRequest {
  /**
   * A Boolean value that determines whether chat messages must contain only
   * emotes.  
   *   
   * Set to **true** if only emotes are allowed; otherwise, **false**. The
   * default is **false**.
   */
  emoteMode?: boolean,
  /**
   * A Boolean value that determines whether the broadcaster limits how often
   * users in the chat room are allowed to send messages. Set to **true** if
   * the broadcaster applies a wait period between messages; otherwise,
   * **false**. The default is **false**.  
   *   
   * To specify the delay, see the `slow_mode_wait_time` field.
   */
  slowMode?: boolean,
  /**
   * The amount of time, in seconds, that users must wait between sending
   * messages. Set only if `slow_mode` is **true**.  
   *   
   * Possible values are: 3 (3 second delay) through 120 (2 minute delay). The
   * default is 30 seconds.
   */
  slowModeWaitTime?: number,
  /**
   * A Boolean value that determines whether only users that subscribe to the
   * broadcaster’s channel may talk in the chat room.  
   *   
   * Set to **true** if the broadcaster restricts the chat room to subscribers
   * only; otherwise, **false**. The default is **false**.
   */
  subscriberMode?: boolean,
  /**
   * A Boolean value that determines whether the broadcaster requires users to
   * post only unique messages in the chat room.  
   *   
   * Set to **true** if the broadcaster allows only unique messages; otherwise,
   * **false**. The default is **false**.
   */
  uniqueChatMode?: boolean,
  /**
   * The amount of time, in seconds, that messages are delayed before appearing
   * in chat. Set only if `non_moderator_chat_delay` is **true**. Possible
   * values are:  
   *   
   * * 2 — 2 second delay (recommended)
   * * 4 — 4 second delay
   * * 6 — 6 second delay
   */
  nonModeratorChatDelayDuration?: number,
  /**
   * A Boolean value that determines whether the broadcaster adds a short delay
   * before chat messages appear in the chat room. This gives chat moderators
   * and bots a chance to remove them before viewers can see the message.  
   *   
   * Set to **true** if the broadcaster applies a delay; otherwise, **false**.
   * The default is **false**.  
   *   
   * To specify the length of the delay, see the
   * `non_moderator_chat_delay_duration` field.
   */
  nonModeratorChatDelay?: boolean,
  /**
   * The length of time, in minutes, that users must follow the broadcaster
   * before being able to participate in the chat room. Set only if
   * `follower_mode` is **true**. Possible values are: 0 (no restriction)
   * through 129600 (3 months). The default is 0.
   */
  followerModeDuration?: number,
  /**
   * A Boolean value that determines whether the broadcaster restricts the chat
   * room to followers only.  
   *   
   * Set to **true** if the broadcaster restricts the chat room to followers
   * only; otherwise, **false**. The default is **true**.  
   *   
   * To specify how long users must follow the broadcaster before being able to
   * participate in the chat room, see the `follower_mode_duration` field.
   */
  followerMode?: boolean,
  /**
   * The ID of the broadcaster whose chat settings you want to update.
   */
  broadcasterId: string,
}
export interface SendAShoutoutRequest {
  /**
   * The ID of the broadcaster that’s sending the Shoutout.
   */
  fromBroadcasterId: string,
  /**
   * The ID of the broadcaster that’s receiving the Shoutout.
   */
  toBroadcasterId: string,
}
export const GetChannelChatBadgesResponse = z.object({
  /**
   * The list of chat badges. The list is sorted in ascending order by
   * `set_id`, and within a set, the list is sorted in ascending order by
   * `id`.
   */
  "data": z.object({
    "set_id": z.string(),
    "versions": z.object({
      "click_action": z.string(),
      "click_url": z.string(),
      "description": z.string(),
      "id": z.string(),
      "image_url_1x": z.string(),
      "image_url_2x": z.string(),
      "image_url_4x": z.string(),
      "title": z.string()
    }).transform((it) => ({
      /**
       * The action to take when clicking on the badge. Set to `null` if
       * no action is specified.
       */
      "clickAction": it["click_action"],
      /**
       * The URL to navigate to when clicking on the badge. Set to `null`
       * if no URL is specified.
       */
      "clickUrl": it["click_url"],
      /**
       * The description of the badge.
       */
      "description": it["description"],
      /**
       * An ID that identifies this version of the badge. The ID can be
       * any value. For example, for Bits, the ID is the Bits tier level,
       * but for World of Warcraft, it could be Alliance or Horde.
       */
      "id": it["id"],
      /**
       * A URL to the small version (18px x 18px) of the badge.
       */
      "imageUrl1x": it["image_url_1x"],
      /**
       * A URL to the medium version (36px x 36px) of the badge.
       */
      "imageUrl2x": it["image_url_2x"],
      /**
       * A URL to the large version (72px x 72px) of the badge.
       */
      "imageUrl4x": it["image_url_4x"],
      /**
       * The title of the badge.
       */
      "title": it["title"],

    })).array()
  }).transform((it) => ({
    /**
     * An ID that identifies this set of chat badges. For example, Bits or
     * Subscriber.
     */
    "setId": it["set_id"],
    /**
     * The list of chat badges in this set.
     */
    "versions": it["versions"],

  })).array()
});
export interface GetChannelChatBadgesResponse extends z.infer<typeof GetChannelChatBadgesResponse> {}

export const GetGlobalChatBadgesResponse = z.object({
  /**
   * The list of chat badges. The list is sorted in ascending order by
   * `set_id`, and within a set, the list is sorted in ascending order by
   * `id`.
   */
  "data": z.object({
    "set_id": z.string(),
    "versions": z.object({
      "click_action": z.string(),
      "click_url": z.string(),
      "description": z.string(),
      "id": z.string(),
      "image_url_1x": z.string(),
      "image_url_2x": z.string(),
      "image_url_4x": z.string(),
      "title": z.string()
    }).transform((it) => ({
      /**
       * The action to take when clicking on the badge. Set to `null` if
       * no action is specified.
       */
      "clickAction": it["click_action"],
      /**
       * The URL to navigate to when clicking on the badge. Set to `null`
       * if no URL is specified.
       */
      "clickUrl": it["click_url"],
      /**
       * The description of the badge.
       */
      "description": it["description"],
      /**
       * An ID that identifies this version of the badge. The ID can be
       * any value. For example, for Bits, the ID is the Bits tier level,
       * but for World of Warcraft, it could be Alliance or Horde.
       */
      "id": it["id"],
      /**
       * A URL to the small version (18px x 18px) of the badge.
       */
      "imageUrl1x": it["image_url_1x"],
      /**
       * A URL to the medium version (36px x 36px) of the badge.
       */
      "imageUrl2x": it["image_url_2x"],
      /**
       * A URL to the large version (72px x 72px) of the badge.
       */
      "imageUrl4x": it["image_url_4x"],
      /**
       * The title of the badge.
       */
      "title": it["title"],

    })).array()
  }).transform((it) => ({
    /**
     * An ID that identifies this set of chat badges. For example, Bits or
     * Subscriber.
     */
    "setId": it["set_id"],
    /**
     * The list of chat badges in this set.
     */
    "versions": it["versions"],

  })).array()
});
export interface GetGlobalChatBadgesResponse extends z.infer<typeof GetGlobalChatBadgesResponse> {}

export const GetChattersResponse = z.object({
  /**
   * The list of users that are connected to the broadcaster’s chat
   * room. The list is empty if no users are connected to the chat room.
   */
  "data": z.object({
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The ID of a user that’s connected to the broadcaster’s chat
     * room.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional(),
  /**
   * The total number of users that are connected to the broadcaster’s
   * chat room. As you page through the list, the number of users may
   * change as users join and leave the chat room.
   */
  "total": z.number()
});
export interface GetChattersResponse extends z.infer<typeof GetChattersResponse> {}

export const GetUserChatColorResponse = z.object({
  /**
   * The list of users and the color code they use for their name.
   */
  "data": z.object({
    "color": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The Hex color code that the user uses in chat for their name. If
     * the user hasn’t specified a color in their settings, the string
     * is empty.
     */
    "color": it["color"],
    /**
     * An ID that uniquely identifies the user.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array()
});
export interface GetUserChatColorResponse extends z.infer<typeof GetUserChatColorResponse> {}

export const GetChannelEmotesResponse = z.object({
  /**
   * The list of emotes that the specified broadcaster created. If the
   * broadcaster hasn't created custom emotes, the list is empty.
   */
  "data": z.object({
    "emote_set_id": z.string(),
    "emote_type": z.enum(["bitstier", "follower", "subscriptions"]),
    "format": z.enum(["animated", "static"]).array(),
    "id": z.string(),
    "images": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * A URL to the small version (28px x 28px) of the emote.
       */
      "url1x": it["url_1x"],
      /**
       * A URL to the medium version (56px x 56px) of the emote.
       */
      "url2x": it["url_2x"],
      /**
       * A URL to the large version (112px x 112px) of the emote.
       */
      "url4x": it["url_4x"],

    })),
    "name": z.string(),
    "scale": z.enum(["1.0", "2.0", "3.0"]).array(),
    "theme_mode": z.enum(["dark", "light"]).array(),
    "tier": z.string()
  }).transform((it) => ({
    /**
     * An ID that identifies the emote set that the emote belongs to.
     */
    "emoteSetId": it["emote_set_id"],
    /**
     * The type of emote. The possible values are:  
     *   
     * * bitstier — A custom Bits tier emote.
     * * follower — A custom follower emote.
     * * subscriptions — A custom subscriber emote.
     */
    "emoteType": it["emote_type"],
    /**
     * The formats that the emote is available in. For example, if the
     * emote is available only as a static PNG, the array contains only
     * `static`. But if the emote is available as a static PNG and an
     * animated GIF, the array contains `static` and `animated`. The
     * possible formats are:  
     *   
     * * animated — An animated GIF is available for this emote.
     * * static — A static PNG file is available for this emote.
     */
    "format": it["format"],
    /**
     * An ID that identifies this emote.
     */
    "id": it["id"],
    /**
     * The image URLs for the emote. These image URLs always provide a
     * static, non-animated emote image with a light background.  
     *   
     * **NOTE:** You should use the templated URL in the `template` field
     * to fetch the image instead of using these URLs.
     */
    "images": it["images"],
    /**
     * The name of the emote. This is the name that viewers type in the
     * chat window to get the emote to appear.
     */
    "name": it["name"],
    /**
     * The sizes that the emote is available in. For example, if the emote
     * is available in small and medium sizes, the array contains 1.0 and
     * 2.0\. Possible sizes are:  
     *   
     * * 1.0 — A small version (28px x 28px) is available.
     * * 2.0 — A medium version (56px x 56px) is available.
     * * 3.0 — A large version (112px x 112px) is available.
     */
    "scale": it["scale"],
    /**
     * The background themes that the emote is available in. Possible
     * themes are:  
     *   
     * * dark
     * * light
     */
    "themeMode": it["theme_mode"],
    /**
     * The subscriber tier at which the emote is unlocked. This field
     * contains the tier information only if `emote_type` is set to
     * `subscriptions`, otherwise, it's an empty string.
     */
    "tier": it["tier"],

  })).array(),
  /**
   * A templated URL. Use the values from the `id`, `format`, `scale`, and
   * `theme_mode` fields to replace the like-named placeholder strings in
   * the templated URL to create a CDN (content delivery network) URL that
   * you use to fetch the emote. For information about what the template
   * looks like and how to use it to fetch emotes, see [Emote CDN URL
   * format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You
   * should use this template instead of using the URLs in the `images`
   * object.
   */
  "template": z.string()
});
export interface GetChannelEmotesResponse extends z.infer<typeof GetChannelEmotesResponse> {}

export const GetGlobalEmotesResponse = z.object({
  /**
   * The list of global emotes.
   */
  "data": z.object({
    "format": z.enum(["animated", "static"]).array(),
    "id": z.string(),
    "images": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * A URL to the small version (28px x 28px) of the emote.
       */
      "url1x": it["url_1x"],
      /**
       * A URL to the medium version (56px x 56px) of the emote.
       */
      "url2x": it["url_2x"],
      /**
       * A URL to the large version (112px x 112px) of the emote.
       */
      "url4x": it["url_4x"],

    })),
    "name": z.string(),
    "scale": z.enum(["1.0", "2.0", "3.0"]).array(),
    "theme_mode": z.enum(["dark", "light"]).array()
  }).transform((it) => ({
    /**
     * The formats that the emote is available in. For example, if the
     * emote is available only as a static PNG, the array contains only
     * `static`. But if the emote is available as a static PNG and an
     * animated GIF, the array contains `static` and `animated`. The
     * possible formats are:  
     *   
     * * animated — An animated GIF is available for this emote.
     * * static — A static PNG file is available for this emote.
     */
    "format": it["format"],
    /**
     * An ID that identifies this emote.
     */
    "id": it["id"],
    /**
     * The image URLs for the emote. These image URLs always provide a
     * static, non-animated emote image with a light background.  
     *   
     * **NOTE:** You should use the templated URL in the `template` field
     * to fetch the image instead of using these URLs.
     */
    "images": it["images"],
    /**
     * The name of the emote. This is the name that viewers type in the
     * chat window to get the emote to appear.
     */
    "name": it["name"],
    /**
     * The sizes that the emote is available in. For example, if the emote
     * is available in small and medium sizes, the array contains 1.0 and
     * 2.0\. Possible sizes are:  
     *   
     * * 1.0 — A small version (28px x 28px) is available.
     * * 2.0 — A medium version (56px x 56px) is available.
     * * 3.0 — A large version (112px x 112px) is available.
     */
    "scale": it["scale"],
    /**
     * The background themes that the emote is available in. Possible
     * themes are:  
     *   
     * * dark
     * * light
     */
    "themeMode": it["theme_mode"],

  })).array(),
  /**
   * A templated URL. Use the values from the `id`, `format`, `scale`, and
   * `theme_mode` fields to replace the like-named placeholder strings in
   * the templated URL to create a CDN (content delivery network) URL that
   * you use to fetch the emote. For information about what the template
   * looks like and how to use it to fetch emotes, see [Emote CDN URL
   * format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You
   * should use this template instead of using the URLs in the `images`
   * object.
   */
  "template": z.string()
});
export interface GetGlobalEmotesResponse extends z.infer<typeof GetGlobalEmotesResponse> {}

export const GetEmoteSetsResponse = z.object({
  /**
   * The list of emotes found in the specified emote sets. The list is
   * empty if none of the IDs were found. The list is in the same order as
   * the set IDs specified in the request. Each set contains one or more
   * emoticons.
   */
  "data": z.object({
    "emote_set_id": z.string(),
    "emote_type": z.enum(["bitstier", "follower", "subscriptions"]),
    "format": z.enum(["animated", "static"]).array(),
    "id": z.string(),
    "images": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * A URL to the small version (28px x 28px) of the emote.
       */
      "url1x": it["url_1x"],
      /**
       * A URL to the medium version (56px x 56px) of the emote.
       */
      "url2x": it["url_2x"],
      /**
       * A URL to the large version (112px x 112px) of the emote.
       */
      "url4x": it["url_4x"],

    })),
    "name": z.string(),
    "owner_id": z.string(),
    "scale": z.enum(["1.0", "2.0", "3.0"]).array(),
    "theme_mode": z.enum(["dark", "light"]).array()
  }).transform((it) => ({
    /**
     * An ID that identifies the emote set that the emote belongs to.
     */
    "emoteSetId": it["emote_set_id"],
    /**
     * The type of emote. The possible values are:   
     *   
     * * bitstier — A Bits tier emote.
     * * follower — A follower emote.
     * * subscriptions — A subscriber emote.
     */
    "emoteType": it["emote_type"],
    /**
     * The formats that the emote is available in. For example, if the
     * emote is available only as a static PNG, the array contains only
     * `static`. But if the emote is available as a static PNG and an
     * animated GIF, the array contains `static` and `animated`. The
     * possible formats are:   
     *   
     * * animated — An animated GIF is available for this emote.
     * * static — A static PNG file is available for this emote.
     */
    "format": it["format"],
    /**
     * An ID that uniquely identifies this emote.
     */
    "id": it["id"],
    /**
     * The image URLs for the emote. These image URLs always provide a
     * static, non-animated emote image with a light background.  
     *   
     * **NOTE:** You should use the templated URL in the `template` field
     * to fetch the image instead of using these URLs.
     */
    "images": it["images"],
    /**
     * The name of the emote. This is the name that viewers type in the
     * chat window to get the emote to appear.
     */
    "name": it["name"],
    /**
     * The ID of the broadcaster who owns the emote.
     */
    "ownerId": it["owner_id"],
    /**
     * The sizes that the emote is available in. For example, if the emote
     * is available in small and medium sizes, the array contains 1.0 and
     * 2.0\. Possible sizes are:   
     *   
     * * 1.0 — A small version (28px x 28px) is available.
     * * 2.0 — A medium version (56px x 56px) is available.
     * * 3.0 — A large version (112px x 112px) is available.
     */
    "scale": it["scale"],
    /**
     * The background themes that the emote is available in. Possible
     * themes are:   
     *   
     * * dark
     * * light
     */
    "themeMode": it["theme_mode"],

  })).array(),
  /**
   * A templated URL. Use the values from the `id`, `format`, `scale`, and
   * `theme_mode` fields to replace the like-named placeholder strings in
   * the templated URL to create a CDN (content delivery network) URL that
   * you use to fetch the emote. For information about what the template
   * looks like and how to use it to fetch emotes, see [Emote CDN URL
   * format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You
   * should use this template instead of using the URLs in the `images`
   * object.
   */
  "template": z.string()
});
export interface GetEmoteSetsResponse extends z.infer<typeof GetEmoteSetsResponse> {}

export const GetUserEmotesResponse = z.object({
  /**
   * 
   */
  "data": z.object({
    "emote_set_id": z.string(),
    "emote_type": z.enum(["none", "bitstier", "follower", "subscriptions", "channelpoints", "rewards", "hypetrain", "prime", "turbo", "smilies", "globals", "owl2019", "twofactor", "limitedtime"]),
    "format": z.string().array(),
    "id": z.string(),
    "name": z.string(),
    "owner_id": z.string(),
    "scale": z.string().array(),
    "theme_mode": z.string().array()
  }).transform((it) => ({
    /**
     * An ID that identifies the emote set that the emote belongs to.
     */
    "emoteSetId": it["emote_set_id"],
    /**
     * The type of emote. The possible values are:   
     *   
     * * **none** — No emote type was assigned to this emote.
     * * **bitstier** — A Bits tier emote.
     * * **follower** — A follower emote.
     * * **subscriptions** — A subscriber emote.
     * * **channelpoints** — An emote granted by using channel points.
     * * **rewards** — An emote granted to the user through a special
     * event.
     * * **hypetrain** — An emote granted for participation in a Hype
     * Train.
     * * **prime** — An emote granted for linking an Amazon Prime
     * account.
     * * **turbo** — An emote granted for having Twitch Turbo.
     * * **smilies** — Emoticons supported by Twitch.
     * * **globals** — An emote accessible by everyone.
     * * **owl2019** — Emotes related to Overwatch League 2019.
     * * **twofactor** — Emotes granted by enabling two-factor
     * authentication on an account.
     * * **limitedtime** — Emotes that were granted for only a limited
     * time.
     */
    "emoteType": it["emote_type"],
    /**
     * The formats that the emote is available in. For example, if the
     * emote is available only as a static PNG, the array contains only
     * static. But if the emote is available as a static PNG and an
     * animated GIF, the array contains static and animated.   
     *   
     * * **animated** — An animated GIF is available for this emote.
     * * **static** — A static PNG file is available for this emote.
     */
    "format": it["format"],
    /**
     * An ID that uniquely identifies this emote.
     */
    "id": it["id"],
    /**
     * The User ID of broadcaster whose channel is receiving the unban
     * request.
     */
    "name": it["name"],
    /**
     * The ID of the broadcaster who owns the emote.
     */
    "ownerId": it["owner_id"],
    /**
     * The sizes that the emote is available in. For example, if the emote
     * is available in small and medium sizes, the array contains 1.0 and
     * 2.0\.   
     *   
     * * **1.0** — A small version (28px x 28px) is available.
     * * **2.0** — A medium version (56px x 56px) is available.
     * * **3.0** — A large version (112px x 112px) is available.
     */
    "scale": it["scale"],
    /**
     * The background themes that the emote is available in.   
     *   
     * * **dark**
     * * **light**
     */
    "themeMode": it["theme_mode"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * 
   *   
   * For more information about pagination support, see [Twitch API Guide
   * - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s after query parameter.
     */
    "cursor": z.string().optional()
  }).optional(),
  /**
   * A templated URL. Uses the values from the _id_, _format_, _scale_,
   * and _theme\_mode_ fields to replace the like-named placeholder
   * strings in the templated URL to create a CDN (content delivery
   * network) URL that you use to fetch the emote.   
   *   
   * For information about what the template looks like and how to use it
   * to fetch emotes, see [Emote CDN
   * URL](https://dev.twitch.tv/docs/irc/emotes#cdn-template) format.
   */
  "template": z.string()
});
export interface GetUserEmotesResponse extends z.infer<typeof GetUserEmotesResponse> {}

export const SendChatMessageResponse = z.object({
  /**
   * 
   */
  "data": z.object({
    "drop_reason": z.object({
      /**
       * Code for why the message was dropped.
       */
      "code": z.string(),
      /**
       * Message for why the message was dropped.
       */
      "message": z.string()
    }).optional(),
    "is_sent": z.boolean(),
    "message_id": z.string()
  }).transform((it) => ({
    /**
     * The reason the message was dropped, if any.
     */
    "dropReason": it["drop_reason"],
    /**
     * If the message passed all checks and was sent.
     */
    "isSent": it["is_sent"],
    /**
     * The message id for the message that was sent.
     */
    "messageId": it["message_id"],

  })).array()
});
export interface SendChatMessageResponse extends z.infer<typeof SendChatMessageResponse> {}

export const GetChatSettingsResponse = z.object({
  /**
   * The list of chat settings. The list contains a single object with all
   * the settings.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "emote_mode": z.boolean(),
    "follower_mode": z.boolean(),
    "follower_mode_duration": z.number(),
    "moderator_id": z.string().optional(),
    "non_moderator_chat_delay": z.boolean().optional(),
    "non_moderator_chat_delay_duration": z.number().optional(),
    "slow_mode": z.boolean(),
    "slow_mode_wait_time": z.number(),
    "subscriber_mode": z.boolean(),
    "unique_chat_mode": z.boolean()
  }).transform((it) => ({
    /**
     * The ID of the broadcaster specified in the request.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * A Boolean value that determines whether chat messages must contain
     * only emotes. Is **true** if chat messages may contain only emotes;
     * otherwise, **false**.
     */
    "emoteMode": it["emote_mode"],
    /**
     * A Boolean value that determines whether the broadcaster restricts
     * the chat room to followers only.  
     *   
     * Is **true** if the broadcaster restricts the chat room to followers
     * only; otherwise, **false**.  
     *   
     * See the `follower_mode_duration` field for how long users must
     * follow the broadcaster before being able to participate in the chat
     * room.
     */
    "followerMode": it["follower_mode"],
    /**
     * The length of time, in minutes, that users must follow the
     * broadcaster before being able to participate in the chat room. Is
     * **null** if `follower_mode` is **false**.
     */
    "followerModeDuration": it["follower_mode_duration"],
    /**
     * The moderator’s ID. The response includes this field only if the
     * request specifies a user access token that includes the
     * **moderator:read:chat\_settings** scope.
     */
    "moderatorId": it["moderator_id"],
    /**
     * A Boolean value that determines whether the broadcaster adds a
     * short delay before chat messages appear in the chat room. This
     * gives chat moderators and bots a chance to remove them before
     * viewers can see the message. See the
     * `non_moderator_chat_delay_duration` field for the length of the
     * delay. Is **true** if the broadcaster applies a delay; otherwise,
     * **false**.  
     *   
     * The response includes this field only if the request specifies a
     * user access token that includes the
     * **moderator:read:chat\_settings** scope and the user in the
     * _moderator\_id_ query parameter is one of the broadcaster’s
     * moderators.
     */
    "nonModeratorChatDelay": it["non_moderator_chat_delay"],
    /**
     * The amount of time, in seconds, that messages are delayed before
     * appearing in chat. Is **null** if `non_moderator_chat_delay` is
     * **false**.  
     *   
     * The response includes this field only if the request specifies a
     * user access token that includes the
     * **moderator:read:chat\_settings** scope and the user in the
     * _moderator\_id_ query parameter is one of the broadcaster’s
     * moderators.
     */
    "nonModeratorChatDelayDuration": it["non_moderator_chat_delay_duration"],
    /**
     * A Boolean value that determines whether the broadcaster limits how
     * often users in the chat room are allowed to send messages.  
     *   
     * Is **true** if the broadcaster applies a delay; otherwise,
     * **false**.  
     *   
     * See the `slow_mode_wait_time` field for the delay.
     */
    "slowMode": it["slow_mode"],
    /**
     * The amount of time, in seconds, that users must wait between
     * sending messages.  
     *   
     * Is **null** if slow\_mode is **false**.
     */
    "slowModeWaitTime": it["slow_mode_wait_time"],
    /**
     * A Boolean value that determines whether only users that subscribe
     * to the broadcaster’s channel may talk in the chat room.  
     *   
     * Is **true** if the broadcaster restricts the chat room to
     * subscribers only; otherwise, **false**.
     */
    "subscriberMode": it["subscriber_mode"],
    /**
     * A Boolean value that determines whether the broadcaster requires
     * users to post only unique messages in the chat room.  
     *   
     * Is **true** if the broadcaster requires unique messages only;
     * otherwise, **false**.
     */
    "uniqueChatMode": it["unique_chat_mode"],

  })).array()
});
export interface GetChatSettingsResponse extends z.infer<typeof GetChatSettingsResponse> {}

export const UpdateChatSettingsResponse = z.object({
  /**
   * The list of chat settings. The list contains a single object with all
   * the settings.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "emote_mode": z.boolean(),
    "follower_mode": z.boolean(),
    "follower_mode_duration": z.number(),
    "moderator_id": z.string().optional(),
    "non_moderator_chat_delay": z.boolean(),
    "non_moderator_chat_delay_duration": z.number(),
    "slow_mode": z.boolean(),
    "slow_mode_wait_time": z.number(),
    "subscriber_mode": z.boolean(),
    "unique_chat_mode": z.boolean()
  }).transform((it) => ({
    /**
     * The ID of the broadcaster specified in the request.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * A Boolean value that determines whether chat messages must contain
     * only emotes. Is **true** if chat messages may contain only emotes;
     * otherwise, **false**.
     */
    "emoteMode": it["emote_mode"],
    /**
     * A Boolean value that determines whether the broadcaster restricts
     * the chat room to followers only.  
     *   
     * Is **true** if the broadcaster restricts the chat room to followers
     * only; otherwise, **false**.  
     *   
     * See the `follower_mode_duration` field for how long users must
     * follow the broadcaster before being able to participate in the chat
     * room.
     */
    "followerMode": it["follower_mode"],
    /**
     * The length of time, in minutes, that users must follow the
     * broadcaster before being able to participate in the chat room. Is
     * **null** if `follower_mode` is **false**.
     */
    "followerModeDuration": it["follower_mode_duration"],
    /**
     * The moderator’s ID. The response includes this field only if the
     * request specifies a user access token that includes the
     * **moderator:read:chat\_settings** scope.
     */
    "moderatorId": it["moderator_id"],
    /**
     * A Boolean value that determines whether the broadcaster adds a
     * short delay before chat messages appear in the chat room. This
     * gives chat moderators and bots a chance to remove them before
     * viewers can see the message. See the
     * `non_moderator_chat_delay_duration` field for the length of the
     * delay. Is **true** if the broadcaster applies a delay; otherwise,
     * **false**.
     */
    "nonModeratorChatDelay": it["non_moderator_chat_delay"],
    /**
     * The amount of time, in seconds, that messages are delayed before
     * appearing in chat. Is **null** if `non_moderator_chat_delay` is
     * **false**.
     */
    "nonModeratorChatDelayDuration": it["non_moderator_chat_delay_duration"],
    /**
     * A Boolean value that determines whether the broadcaster limits how
     * often users in the chat room are allowed to send messages.  
     *   
     * Is **true** if the broadcaster applies a delay; otherwise,
     * **false**.  
     *   
     * See the `slow_mode_wait_time` field for the delay.
     */
    "slowMode": it["slow_mode"],
    /**
     * The amount of time, in seconds, that users must wait between
     * sending messages.  
     *   
     * Is **null** if slow\_mode is **false**.
     */
    "slowModeWaitTime": it["slow_mode_wait_time"],
    /**
     * A Boolean value that determines whether only users that subscribe
     * to the broadcaster’s channel may talk in the chat room.  
     *   
     * Is **true** if the broadcaster restricts the chat room to
     * subscribers only; otherwise, **false**.
     */
    "subscriberMode": it["subscriber_mode"],
    /**
     * A Boolean value that determines whether the broadcaster requires
     * users to post only unique messages in the chat room.  
     *   
     * Is **true** if the broadcaster requires unique messages only;
     * otherwise, **false**.
     */
    "uniqueChatMode": it["unique_chat_mode"],

  })).array()
});
export interface UpdateChatSettingsResponse extends z.infer<typeof UpdateChatSettingsResponse> {}



export class Chat {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Sends an announcement to the broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:announcements** scope.
   */
  async sendChatAnnouncement(options: SendChatAnnouncementRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/announcements", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.color = options.color;
    body.message = options.message;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s list of custom chat badges. The list is empty if
   * the broadcaster hasn’t created custom chat badges. For information about
   * custom badges, see [subscriber
   * badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits
   * badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getChannelChatBadges(options: GetChannelChatBadgesRequest): Promise<GetChannelChatBadgesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/badges", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelChatBadgesResponse);
  }
  /**
   * Gets Twitch’s list of chat badges, which users may use in any
   * channel’s chat room. For information about chat badges, see [Twitch Chat
   * Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   * 
   * __Request Query Parameters:__
   * 
   * None
   */
  async getGlobalChatBadges(): Promise<GetGlobalChatBadgesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/badges/global", this.#twitch.base);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetGlobalChatBadgesResponse);
  }
  /**
   * Gets the list of users that are connected to the broadcaster’s chat
   * session.
   * 
   * **NOTE**: There is a delay between when users join and leave a chat and
   * when the list is updated accordingly.
   * 
   * To determine whether a user is a moderator or VIP, use the [Get
   * Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and
   * [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints.
   * You can check the roles of up to 100 users.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:read:chatters** scope.
   */
  async getChatters(options: GetChattersRequest): Promise<GetChattersResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/chatters", this.#twitch.base);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    url.searchParams.append("moderator_id", snapshot.userId);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChattersResponse);
  }
  /**
   * Gets the color used for the user’s name in chat.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getUserChatColor(options: GetUserChatColorRequest): Promise<GetUserChatColorResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/color", this.#twitch.base);
    for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUserChatColorResponse);
  }
  /**
   * Updates the color used for the user’s name in chat.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:manage:chat\_color** scope.
   */
  async updateUserChatColor(options: UpdateUserChatColorRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/color", this.#twitch.base);
    url.searchParams.append("user_id", snapshot.userId);
    url.searchParams.append("color", options.color.toString());
    const opts: RequestInit = { method: 'PUT' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s list of custom emotes. Broadcasters create these
   * custom emotes for users who subscribe to or follow the channel or cheer
   * Bits in the channel’s chat window. [Learn
   * More](https://dev.twitch.tv/docs/irc/emotes)
   * 
   * For information about the custom emotes, see [subscriber
   * emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits
   * tier
   * emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language=bg#slots), 
   * and [follower
   * emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).
   * 
   * **NOTE:** With the exception of custom follower emotes, users may use
   * custom emotes in any Twitch chat.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getChannelEmotes(options: GetChannelEmotesRequest): Promise<GetChannelEmotesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/emotes", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChannelEmotesResponse);
  }
  /**
   * Gets the list of [global
   * emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/).
   * Global emotes are Twitch-created emotes that users can use in any Twitch
   * chat.
   * 
   * [Learn More](https://dev.twitch.tv/docs/irc/emotes)
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   * 
   * __Request Query Parameters:__
   * 
   * None
   */
  async getGlobalEmotes(): Promise<GetGlobalEmotesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/emotes/global", this.#twitch.base);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetGlobalEmotesResponse);
  }
  /**
   * Gets emotes for one or more specified emote sets.
   * 
   * An emote set groups emotes that have a similar context. For example,
   * Twitch places all the subscriber emotes that a broadcaster uploads for
   * their channel in the same emote set.
   * 
   * [Learn More](https://dev.twitch.tv/docs/irc/emotes)
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getEmoteSets(options: GetEmoteSetsRequest): Promise<GetEmoteSetsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/emotes/set", this.#twitch.base);
    for (const value of options.emoteSetId) {
      url.searchParams.append("emote_set_id", value.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetEmoteSetsResponse);
  }
  /**
   * NEW Retrieves emotes available to the user across all channels.
   * 
   * __Authorization:__
   * 
   * * Requires a user access token that includes the **user:read:emotes**
   * scope.
   * * Query parameter `user_id` must match the `user_id` in the user access
   * token.
   */
  async getUserEmotes(options: GetUserEmotesRequest): Promise<GetUserEmotesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/emotes/user", this.#twitch.base);
    url.searchParams.append("user_id", snapshot.userId);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.broadcasterId) {
      url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUserEmotesResponse);
  }
  /**
   * NEW Sends a message to the broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the `user:write:chat` scope. If app access token used, then
   * additionally requires `user:bot` scope from chatting user, and either
   * `channel:bot` scope from broadcaster or moderator status.
   */
  async sendChatMessage(options: SendChatMessageRequest): Promise<SendChatMessageResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/messages", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.reply_parent_message_id = options.replyParentMessageId;
    body.message = options.message;
    body.sender_id = snapshot.userId;
    body.broadcaster_id = options.broadcasterId;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, SendChatMessageResponse);
  }
  /**
   * Gets the broadcaster’s chat settings.
   * 
   * For an overview of chat settings, see [Chat Commands for Broadcasters and
   * Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and
   * [Moderator
   * Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getChatSettings(options: GetChatSettingsRequest): Promise<GetChatSettingsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/settings", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetChatSettingsResponse);
  }
  /**
   * Updates the broadcaster’s chat settings.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:chat\_settings** scope.
   * 
   * __Request Body:__
   * 
   * All fields are optional. Specify only those fields that you want to
   * update.
   * 
   * To set the `slow_mode_wait_time` or `follower_mode_duration` field to its
   * default value, set the corresponding `slow_mode` or `follower_mode` field
   * to **true** (and don’t include the `slow_mode_wait_time` or
   * `follower_mode_duration` field).
   * 
   * To set the `slow_mode_wait_time`, `follower_mode_duration`, or
   * `non_moderator_chat_delay_duration` field’s value, you must set the
   * corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay`
   * field to **true**.
   * 
   * To remove the `slow_mode_wait_time`, `follower_mode_duration`, or
   * `non_moderator_chat_delay_duration` field’s value, set the corresponding
   * `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to
   * **false** (and don’t include the `slow_mode_wait_time`,
   * `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
   */
  async updateChatSettings(options: UpdateChatSettingsRequest): Promise<UpdateChatSettingsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/settings", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.emote_mode = options.emoteMode;
    body.slow_mode = options.slowMode;
    body.slow_mode_wait_time = options.slowModeWaitTime;
    body.subscriber_mode = options.subscriberMode;
    body.unique_chat_mode = options.uniqueChatMode;
    body.non_moderator_chat_delay_duration = options.nonModeratorChatDelayDuration;
    body.non_moderator_chat_delay = options.nonModeratorChatDelay;
    body.follower_mode_duration = options.followerModeDuration;
    body.follower_mode = options.followerMode;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateChatSettingsResponse);
  }
  /**
   * Sends a Shoutout to the specified broadcaster. Typically, you send
   * Shoutouts when you or one of your moderators notice another broadcaster in
   * your chat, the other broadcaster is coming up in conversation, or after
   * they raid your broadcast.
   * 
   * Twitch’s Shoutout feature is a great way for you to show support for
   * other broadcasters and help them grow. Viewers who do not follow the other
   * broadcaster will see a pop-up Follow button in your chat that they can
   * click to follow the other broadcaster. [Learn
   * More](https://help.twitch.tv/s/article/shoutouts)
   * 
   * **Rate Limits** The broadcaster may send a Shoutout once every 2 minutes.
   * They may send the same broadcaster a Shoutout once every 60 minutes.
   * 
   * To receive notifications when a Shoutout is sent or received, subscribe to
   * the
   * [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) 
   * and
   * [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) 
   * subscription types. The **channel.shoutout.create** event includes
   * cooldown periods that indicate when the broadcaster may send another
   * Shoutout without exceeding the endpoint’s rate limit.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:shoutouts** scope.
   */
  async sendAShoutout(options: SendAShoutoutRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/chat/shoutouts", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("from_broadcaster_id", options.fromBroadcasterId.toString());
    url.searchParams.append("to_broadcaster_id", options.toBroadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    await this.#twitch.request(url, opts);
  }
}
