
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetUsersRequest {
  /**
   * The ID of the user to get. To specify more than one user, include the _id_
   * parameter for each user to get. For example, `id=1234&id=5678`. The
   * maximum number of IDs you may specify is 100.
   */
  id?: string[],
  /**
   * The login name of the user to get. To specify more than one user, include
   * the _login_ parameter for each user to get. For example,
   * `login=foo&login=bar`. The maximum number of login names you may specify
   * is 100.
   */
  login?: string[],
}
export interface UpdateUserRequest {
  /**
   * The string to update the channel’s description to. The description is
   * limited to a maximum of 300 characters.  
   *   
   * To remove the description, specify this parameter but don’t set it’s
   * value (for example, `?description=`).
   */
  description?: string,
}
export interface GetUserBlockListRequest {
  /**
   * The ID of the broadcaster whose list of blocked users you want to get.
   */
  broadcasterId: string,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100\. The default
   * is 20.
   */
  first?: number,
}
export interface BlockUserRequest {
  /**
   * The location where the harassment took place that is causing the
   * brodcaster to block the user. Possible values are:  
   *   
   * * chat
   * * whisper
   *   
   * .
   */
  sourceContext?: | "chat"| "whisper",
  /**
   * The reason that the broadcaster is blocking the user. Possible values are:
   * 
   *   
   * * harassment
   * * spam
   * * other
   */
  reason?: | "harassment"| "spam"| "other",
  /**
   * The ID of the user to block. The API ignores the request if the
   * broadcaster has already blocked the user.
   */
  targetUserId: string,
}
export interface UnblockUserRequest {
  /**
   * The ID of the user to remove from the broadcaster’s list of blocked
   * users. The API ignores the request if the broadcaster hasn’t blocked the
   * user.
   */
  targetUserId: string,
}
export interface GetUserActiveExtensionsRequest {
  /**
   * The ID of the broadcaster whose active extensions you want to get.  
   *   
   * This parameter is required if you specify an app access token and is
   * optional if you specify a user access token. If you specify a user access
   * token and don’t specify this parameter, the API uses the user ID from
   * the access token.
   */
  userId?: string,
}
export interface UpdateUserExtensionsRequest {
  /**
   * The extensions to update. The `data` field is a dictionary of extension
   * types. The dictionary’s possible keys are: panel, overlay, or component.
   * The key’s value is a dictionary of extensions.  
   *   
   * For the extension’s dictionary, the key is a sequential number beginning
   * with 1\. For panel and overlay extensions, the key’s value is an object
   * that contains the following fields: `active` (true/false), `id` (the
   * extension’s ID), and `version` (the extension’s version).  
   *   
   * For component extensions, the key’s value includes the above fields plus
   * the `x` and `y` fields, which identify the coordinate where the extension
   * is placed.
   */
  data: {
  component?: {
    [_: string]: {
      /**
       * A Boolean value that determines the extension’s activation
       * state. If **false**, the user has not configured a component
       * extension.
       */
      active: boolean,
      /**
       * An ID that identifies the extension.
       */
      id?: string,
      /**
       * The extension’s version.
       */
      version?: string,
      /**
       * The x-coordinate where the extension is placed.
       */
      x?: number,
      /**
       * The y-coordinate where the extension is placed.
       */
      y?: number
    }
  },
  overlay?: {
    [_: string]: {
      /**
       * A Boolean value that determines the extension’s activation
       * state. If **false**, the user has not configured an overlay
       * extension.
       */
      active: boolean,
      /**
       * An ID that identifies the extension.
       */
      id?: string,
      /**
       * The extension’s version.
       */
      version?: string
    }
  },
  panel?: {
    [_: string]: {
      /**
       * A Boolean value that determines the extension’s activation
       * state. If **false**, the user has not configured a panel
       * extension.
       */
      active: boolean,
      /**
       * An ID that identifies the extension.
       */
      id?: string,
      /**
       * The extension’s version.
       */
      version?: string
    }
  }
},
}
export const GetUsersResponse = z.object({
  /**
   * The list of users.
   */
  "data": z.object({
    "broadcaster_type": z.enum(["affiliate", "partner", ""]),
    "created_at": z.string(),
    "description": z.string(),
    "display_name": z.string(),
    "email": z.string().optional(),
    "id": z.string(),
    "login": z.string(),
    "offline_image_url": z.string(),
    "profile_image_url": z.string(),
    "type": z.enum(["admin", "global_mod", "staff", ""]),
    "view_count": z.number()
  }).transform((it) => ({
    /**
     * The type of broadcaster. Possible values are:  
     *   
     * * affiliate — An [affiliate
     * broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
     * * partner — A [partner
     * broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
     * * "" — A normal broadcaster
     */
    "broadcasterType": it["broadcaster_type"],
    /**
     * The UTC date and time that the user's account was created. The
     * timestamp is in RFC3339 format.
     */
    "createdAt": it["created_at"],
    /**
     * The user's description of their channel.
     */
    "description": it["description"],
    /**
     * The user's display name.
     */
    "displayName": it["display_name"],
    /**
     * The user's verified email address. The object includes this field
     * only if the user access token includes the **user:read:email**
     * scope.  
     *   
     * If the request contains more than one user, only the user
     * associated with the access token that provided consent will include
     * an email address — the email address for all other users will be
     * empty.
     */
    "email": it["email"],
    /**
     * An ID that identifies the user.
     */
    "id": it["id"],
    /**
     * The user's login name.
     */
    "login": it["login"],
    /**
     * A URL to the user's offline image.
     */
    "offlineImageUrl": it["offline_image_url"],
    /**
     * A URL to the user's profile image.
     */
    "profileImageUrl": it["profile_image_url"],
    /**
     * The type of user. Possible values are:  
     *   
     * * admin — Twitch administrator
     * * global\_mod
     * * staff — Twitch staff
     * * "" — Normal user
     */
    "type": it["type"],
    /**
     * The number of times the user's channel has been viewed.  
     *   
     * **NOTE**: This field has been deprecated (see [Get Users API
     * endpoint – "view\_count"
     * deprecation](https://discuss.dev.twitch.tv/t/get-users-api-endpoint-view-count-deprecation/37777)). 
     * Any data in this field is not valid and should not be used.
     */
    "viewCount": it["view_count"],

  })).array()
});
export interface GetUsersResponse extends z.infer<typeof GetUsersResponse> {}

export const UpdateUserResponse = z.object({
  /**
   * A list contains the single user that you updated.
   */
  "data": z.object({
    "broadcaster_type": z.enum(["affiliate", "partner", ""]),
    "created_at": z.string(),
    "description": z.string(),
    "display_name": z.string(),
    "email": z.string().optional(),
    "id": z.string(),
    "login": z.string(),
    "offline_image_url": z.string(),
    "profile_image_url": z.string(),
    "type": z.enum(["admin", "global_mod", "staff", ""]),
    "view_count": z.number()
  }).transform((it) => ({
    /**
     * The type of broadcaster. Possible values are:  
     *   
     * * affiliate — An [affiliate
     * broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
     * * partner — A [partner
     * broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
     * * "" — A normal broadcaster
     */
    "broadcasterType": it["broadcaster_type"],
    /**
     * The UTC date and time that the user's account was created. The
     * timestamp is in RFC3339 format.
     */
    "createdAt": it["created_at"],
    /**
     * The user's description of their channel.
     */
    "description": it["description"],
    /**
     * The user's display name.
     */
    "displayName": it["display_name"],
    /**
     * The user's verified email address. The object includes this field
     * only if the user access token includes the **user:read:email**
     * scope.  
     *   
     * If the request contains more than one user, only the user
     * associated with the access token that provided consent will include
     * an email address — the email address for all other users will be
     * empty.
     */
    "email": it["email"],
    /**
     * An ID that identifies the user.
     */
    "id": it["id"],
    /**
     * The user's login name.
     */
    "login": it["login"],
    /**
     * A URL to the user's offline image.
     */
    "offlineImageUrl": it["offline_image_url"],
    /**
     * A URL to the user's profile image.
     */
    "profileImageUrl": it["profile_image_url"],
    /**
     * The type of user. Possible values are:  
     *   
     * * admin — Twitch administrator
     * * global\_mod
     * * staff — Twitch staff
     * * "" — Normal user
     */
    "type": it["type"],
    /**
     * The number of times the user's channel has been viewed.  
     *   
     * **NOTE**: This field has been deprecated (see [Get Users API
     * endpoint – "view\_count"
     * deprecation](https://discuss.dev.twitch.tv/t/get-users-api-endpoint-view-count-deprecation/37777)). 
     * Any data in this field is not valid and should not be used.
     */
    "viewCount": it["view_count"],

  })).array()
});
export interface UpdateUserResponse extends z.infer<typeof UpdateUserResponse> {}

export const GetUserBlockListResponse = z.object({
  /**
   * The list of blocked users. The list is in descending order by when
   * the user was blocked.
   */
  "data": z.object({
    "display_name": z.string(),
    "user_id": z.string(),
    "user_login": z.string()
  }).transform((it) => ({
    /**
     * The blocked user’s display name.
     */
    "displayName": it["display_name"],
    /**
     * An ID that identifies the blocked user.
     */
    "userId": it["user_id"],
    /**
     * The blocked user’s login name.
     */
    "userLogin": it["user_login"],

  })).array()
});
export interface GetUserBlockListResponse extends z.infer<typeof GetUserBlockListResponse> {}

export const GetUserActiveExtensionsResponse = z.object({
  /**
   * The active extensions that the broadcaster has installed.
   */
  "data": z.object({
    /**
     * A dictionary that contains the data for a video-component
     * extension. The dictionary’s key is a sequential number beginning
     * with 1\. The following fields contain the component’s data for
     * each key.
     */
    "component": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured a component
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional(),
        /**
         * The x-coordinate where the extension is placed.
         */
        "x": z.number().optional(),
        /**
         * The y-coordinate where the extension is placed.
         */
        "y": z.number().optional()
      })).optional(),
    /**
     * A dictionary that contains the data for a video-overlay extension.
     * The dictionary’s key is a sequential number beginning with 1\.
     * The following fields contain the overlay’s data for each key.
     */
    "overlay": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured an overlay
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional()
      })).optional(),
    /**
     * A dictionary that contains the data for a panel extension. The
     * dictionary’s key is a sequential number beginning with 1\. The
     * following fields contain the panel’s data for each key.
     */
    "panel": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured a panel
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional()
      })).optional()
  }).optional()
});
export interface GetUserActiveExtensionsResponse extends z.infer<typeof GetUserActiveExtensionsResponse> {}

export const UpdateUserExtensionsResponse = z.object({
  /**
   * The extensions that the broadcaster updated.
   */
  "data": z.object({
    /**
     * A dictionary that contains the data for a video-component
     * extension. The dictionary’s key is a sequential number beginning
     * with 1\. The following fields contain the component’s data for
     * each key.
     */
    "component": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured a component
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional(),
        /**
         * The x-coordinate where the extension is placed.
         */
        "x": z.number().optional(),
        /**
         * The y-coordinate where the extension is placed.
         */
        "y": z.number().optional()
      })),
    /**
     * A dictionary that contains the data for a video-overlay extension.
     * The dictionary’s key is a sequential number beginning with 1\.
     * The following fields contain the overlay’s data for each key.
     */
    "overlay": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured an overlay
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional()
      })),
    /**
     * A dictionary that contains the data for a panel extension. The
     * dictionary’s key is a sequential number beginning with 1\. The
     * following fields contain the panel’s data for each key.
     */
    "panel": z.object({}).catchall(z.object({
        /**
         * A Boolean value that determines the extension’s activation
         * state. If **false**, the user has not configured a panel
         * extension.
         */
        "active": z.boolean(),
        /**
         * An ID that identifies the extension.
         */
        "id": z.string().optional(),
        /**
         * The extension’s name.
         */
        "name": z.string().optional(),
        /**
         * The extension’s version.
         */
        "version": z.string().optional()
      }))
  })
});
export interface UpdateUserExtensionsResponse extends z.infer<typeof UpdateUserExtensionsResponse> {}

export const GetUserExtensionsResponse = z.object({
  /**
   * The list of extensions that the user has installed.
   */
  "data": z.object({
    "can_activate": z.boolean(),
    "id": z.string(),
    "name": z.string(),
    "type": z.enum(["component", "mobile", "overlay", "panel"]).array(),
    "version": z.string()
  }).transform((it) => ({
    /**
     * A Boolean value that determines whether the extension is configured
     * and can be activated. Is **true** if the extension is configured
     * and can be activated.
     */
    "canActivate": it["can_activate"],
    /**
     * An ID that identifies the extension.
     */
    "id": it["id"],
    /**
     * The extension's name.
     */
    "name": it["name"],
    /**
     * The extension types that you can activate for this extension.
     * Possible values are:  
     *   
     * * component
     * * mobile
     * * overlay
     * * panel
     */
    "type": it["type"],
    /**
     * The extension's version.
     */
    "version": it["version"],

  })).array()
});
export interface GetUserExtensionsResponse extends z.infer<typeof GetUserExtensionsResponse> {}



export class Users {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets information about one or more users.  
   *   
   * You may look up users using their user ID, login name, or both but the sum
   * total of the number of users you may look up is 100\. For example, you may
   * specify 50 IDs and 50 names or 100 IDs or names, but you cannot specify
   * 100 IDs and 100 names.  
   *   
   * If you don’t specify IDs or login names, the request returns information
   * about the user in the access token if you specify a user access token.  
   *   
   * To include the user’s verified email address in the response, you must
   * use a user access token that includes the **user:read:email** scope.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getUsers(options: GetUsersRequest): Promise<GetUsersResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users", this.#twitch.base);
    if (options.id) {
      for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    }
    if (options.login) {
      for (const value of options.login) {
      url.searchParams.append("login", value.toString());
    }
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUsersResponse);
  }
  /**
   * Updates the specified user’s information. The user ID in the OAuth token
   * identifies the user whose information you want to update.
   * 
   * To include the user’s verified email address in the response, the user
   * access token must also include the **user:read:email** scope.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:edit** scope.
   */
  async updateUser(options: UpdateUserRequest): Promise<UpdateUserResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users", this.#twitch.base);
    if (options.description) {
      url.searchParams.append("description", options.description.toString());
    }
    const opts: RequestInit = { method: 'PUT' };

    return await this.#twitch.request(url, opts, UpdateUserResponse);
  }
  /**
   * Gets the list of users that the broadcaster has blocked. [Read
   * More](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers)
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:blocked\_users** scope.
   */
  async getUserBlockList(options: GetUserBlockListRequest): Promise<GetUserBlockListResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/blocks", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUserBlockListResponse);
  }
  /**
   * Blocks the specified user from interacting with or having contact with the
   * broadcaster. The user ID in the OAuth token identifies the broadcaster who
   * is blocking the user.
   * 
   * To learn more about blocking users, see [Block Other Users on
   * Twitch](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:manage:blocked\_users** scope.
   */
  async blockUser(options: BlockUserRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/blocks", this.#twitch.base);
    if (options.sourceContext) {
      url.searchParams.append("source_context", options.sourceContext.toString());
    }
    if (options.reason) {
      url.searchParams.append("reason", options.reason.toString());
    }
    url.searchParams.append("target_user_id", options.targetUserId.toString());
    const opts: RequestInit = { method: 'PUT' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Removes the user from the broadcaster’s list of blocked users. The user
   * ID in the OAuth token identifies the broadcaster who’s removing the
   * block.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:manage:blocked\_users** scope.
   */
  async unblockUser(options: UnblockUserRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/blocks", this.#twitch.base);
    url.searchParams.append("target_user_id", options.targetUserId.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the active extensions that the broadcaster has installed for each
   * configuration.
   * 
   * NOTE: To include extensions that you have under development, you must
   * specify a user access token that includes the **user:read:broadcast** or
   * **user:edit:broadcast** scope.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getUserActiveExtensions(options: GetUserActiveExtensionsRequest): Promise<GetUserActiveExtensionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/extensions", this.#twitch.base);
    if (options.userId) {
      url.searchParams.append("user_id", options.userId.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUserActiveExtensionsResponse);
  }
  /**
   * Updates an installed extension’s information. You can update the
   * extension’s activation state, ID, and version number. The user ID in the
   * access token identifies the broadcaster whose extensions you’re
   * updating.
   * 
   * NOTE: If you try to activate an extension under multiple extension types,
   * the last write wins (and there is no guarantee of write order).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:edit:broadcast** scope.
   */
  async updateUserExtensions(options: UpdateUserExtensionsRequest): Promise<UpdateUserExtensionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/extensions", this.#twitch.base);
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.data = options.data;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateUserExtensionsResponse);
  }
  /**
   * Gets a list of all extensions (both active and inactive) that the
   * broadcaster has installed. The user ID in the access token identifies the
   * broadcaster.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:broadcast** or **user:edit:broadcast** scope. To
   * include inactive extensions, you must include the **user:edit:broadcast**
   * scope.
   */
  async getUserExtensions(): Promise<GetUserExtensionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/users/extensions/list", this.#twitch.base);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUserExtensionsResponse);
  }
}
