
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetExtensionBitsProductsRequest {
  /**
   * A Boolean value that determines whether to include disabled or expired
   * Bits products in the response. The default is **false**.
   */
  shouldIncludeAll?: boolean,
}
export interface UpdateExtensionBitsProductRequest {
  /**
   * The date and time, in RFC3339 format, when the product expires. If not
   * set, the product does not expire. To disable the product, set the
   * expiration date to a date in the past.
   */
  expiration?: string,
  /**
   * A Boolean value that determines whether Bits product purchase events are
   * broadcast to all instances of the extension on a channel. The events are
   * broadcast via the `onTransactionComplete` helper callback. The default is
   * **false**.
   */
  isBroadcast?: boolean,
  /**
   * An object that contains the product's cost information.
   */
  cost: {
  /**
   * The product's price.
   */
  amount: number,
  /**
   * The type of currency. Possible values are:  
   *   
   * * bits — The minimum price is 1 and the maximum is 10000.
   */
  type: | "bits"
},
  /**
   * A Boolean value that indicates whether the product is in development. Set
   * to **true** if the product is in development and not available for public
   * use. The default is **false**.
   */
  inDevelopment?: boolean,
  /**
   * The product's SKU. The SKU must be unique within an extension. The
   * product's SKU cannot be changed. The SKU may contain only alphanumeric
   * characters, dashes (-), underscores (\_), and periods (.) and is limited
   * to a maximum of 255 characters. No spaces.
   */
  sku: string,
  /**
   * The product's name as displayed in the extension. The maximum length is
   * 255 characters.
   */
  displayName: string,
}
export interface GetExtensionsRequest {
  /**
   * The version of the extension to get. If not specified, it returns the
   * latest, released version. If you don’t have a released version, you must
   * specify a version; otherwise, the list is empty.
   */
  extensionVersion?: string,
  /**
   * The ID of the extension to get.
   */
  extensionId: string,
}
export interface SendExtensionChatMessageRequest {
  /**
   * The ID of the broadcaster that has activated the extension.
   */
  broadcasterId: string,
  /**
   * The message. The message may contain a maximum of 280 characters.
   */
  text: string,
  /**
   * The extension’s version number.
   */
  extensionVersion: string,
  /**
   * The ID of the extension that’s sending the chat message.
   */
  extensionId: string,
}
export interface GetExtensionConfigurationSegmentRequest {
  /**
   * The ID of the broadcaster that installed the extension. This parameter is
   * required if you set the _segment_ parameter to broadcaster or developer.
   * Do not specify this parameter if you set _segment_ to global.
   */
  broadcasterId?: string,
  /**
   * The ID of the extension that contains the configuration segment you want
   * to get.
   */
  extensionId: string,
  /**
   * The type of configuration segment to get. Possible case-sensitive values
   * are:   
   *   
   * * broadcaster
   * * developer
   * * global
   *   
   * You may specify one or more segments. To specify multiple segments,
   * include the `segment` parameter for each segment to get. For example,
   * `segment=broadcaster&segment=developer`. Ignores duplicate segments.
   */
  segment: | "broadcaster"| "developer"| "global",
}
export interface SetExtensionConfigurationSegmentRequest {
  /**
   * The ID of the broadcaster that installed the extension. Include this field
   * only if the `segment` is set to developer or broadcaster.
   */
  broadcasterId?: string,
  /**
   * The contents of the segment. This string may be a plain-text string or a
   * string-encoded JSON object.
   */
  content?: string,
  /**
   * The ID of the extension to update.
   */
  extensionId: string,
  /**
   * The configuration segment to update. Possible case-sensitive values are:  
   *   
   * * broadcaster
   * * developer
   * * global
   */
  segment: | "broadcaster"| "developer"| "global",
  /**
   * The version number that identifies this definition of the segment’s
   * data. If not specified, the latest definition is updated.
   */
  version?: string,
}
export interface CreateExtensionSecretRequest {
  /**
   * The amount of time, in seconds, to delay activating the secret. The delay
   * should provide enough time for instances of the extension to gracefully
   * switch over to the new secret. The minimum delay is 300 seconds (5
   * minutes). The default is 300 seconds.
   */
  delay?: number,
  /**
   * The ID of the extension to apply the shared secret to.
   */
  extensionId: string,
}
export interface GetExtensionLiveChannelsRequest {
  /**
   * The ID of the extension to get. Returns the list of broadcasters that are
   * live and that have installed or activated this extension.
   */
  extensionId: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: number,
  /**
   * The cursor used to get the next page of results. The `pagination` field in
   * the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
}
export interface SendExtensionPubsubMessageRequest {
  /**
   * A Boolean value that determines whether the message should be sent to all
   * channels where your extension is active. Set to **true** if the message
   * should be sent to all channels. The default is **false**.
   */
  isGlobalBroadcast?: boolean,
  /**
   * The ID of the broadcaster to send the message to. Don’t include this
   * field if `is_global_broadcast` is set to **true**.
   */
  broadcasterId: string,
  /**
   * The message to send. The message can be a plain-text string or a
   * string-encoded JSON object. The message is limited to a maximum of 5 KB.
   */
  message: string,
  /**
   * The target of the message. Possible values are:  
   *   
   * * broadcast
   * * global
   * * whisper-<user-id>
   *   
   * If `is_global_broadcast` is **true**, you must set this field to global.
   * The broadcast and global values are mutually exclusive; specify only one
   * of them.
   */
  target: | "broadcast"| "global"| "whisper-<user-id>"[],
}
export interface GetReleasedExtensionsRequest {
  /**
   * The version of the extension to get. If not specified, it returns the
   * latest version.
   */
  extensionVersion?: string,
  /**
   * The ID of the extension to get.
   */
  extensionId: string,
}
export interface SetExtensionRequiredConfigurationRequest {
  /**
   * The ID of the extension to update.
   */
  extensionId: string,
  /**
   * The version of the extension to update.
   */
  extensionVersion: string,
  /**
   * The ID of the broadcaster that installed the extension on their channel.
   */
  broadcasterId: string,
  /**
   * The required\_configuration string to use with the extension.
   */
  requiredConfiguration: string,
}
export const GetExtensionBitsProductsResponse = z.object({
  /**
   * A list of Bits products that the extension created. The list is in
   * ascending SKU order. The list is empty if the extension hasn’t
   * created any products or they’re all expired or disabled.
   */
  "data": z.object({
    "cost": z.object({
      /**
       * The product's price.
       */
      "amount": z.number(),
      /**
       * The type of currency. Possible values are:  
       *   
       * * bits
       */
      "type": z.enum(["bits"])
    }),
    "display_name": z.string(),
    "expiration": z.string(),
    "in_development": z.boolean(),
    "is_broadcast": z.boolean(),
    "sku": z.string()
  }).transform((it) => ({
    /**
     * An object that contains the product's cost information.
     */
    "cost": it["cost"],
    /**
     * The product's name as displayed in the extension.
     */
    "displayName": it["display_name"],
    /**
     * The date and time, in RFC3339 format, when the product expires.
     */
    "expiration": it["expiration"],
    /**
     * A Boolean value that indicates whether the product is in
     * development. If **true**, the product is not available for public
     * use.
     */
    "inDevelopment": it["in_development"],
    /**
     * A Boolean value that determines whether Bits product purchase
     * events are broadcast to all instances of an extension on a channel.
     * The events are broadcast via the `onTransactionComplete` helper
     * callback. Is **true** if the event is broadcast to all instances.
     */
    "isBroadcast": it["is_broadcast"],
    /**
     * The product's SKU. The SKU is unique across an extension's
     * products.
     */
    "sku": it["sku"],

  })).array()
});
export interface GetExtensionBitsProductsResponse extends z.infer<typeof GetExtensionBitsProductsResponse> {}

export const UpdateExtensionBitsProductResponse = z.object({
  /**
   * A list of Bits products that the extension created. The list is in
   * ascending SKU order. The list is empty if the extension hasn't
   * created any products or they're all expired or disabled.
   */
  "data": z.object({
    "cost": z.object({
      /**
       * The product's price.
       */
      "amount": z.number(),
      /**
       * The type of currency. Possible values are:  
       *   
       * * bits
       */
      "type": z.enum(["bits"])
    }),
    "display_name": z.string(),
    "expiration": z.string(),
    "in_development": z.boolean(),
    "is_broadcast": z.boolean(),
    "sku": z.string()
  }).transform((it) => ({
    /**
     * An object that contains the product's cost information.
     */
    "cost": it["cost"],
    /**
     * The product's name as displayed in the extension.
     */
    "displayName": it["display_name"],
    /**
     * The date and time, in RFC3339 format, when the product expires.
     */
    "expiration": it["expiration"],
    /**
     * A Boolean value that indicates whether the product is in
     * development. If **true**, the product is not available for public
     * use.
     */
    "inDevelopment": it["in_development"],
    /**
     * A Boolean value that determines whether Bits product purchase
     * events are broadcast to all instances of an extension on a channel.
     * The events are broadcast via the `onTransactionComplete` helper
     * callback. Is **true** if the event is broadcast to all instances.
     */
    "isBroadcast": it["is_broadcast"],
    /**
     * The product's SKU. The SKU is unique across an extension's
     * products.
     */
    "sku": it["sku"],

  })).array()
});
export interface UpdateExtensionBitsProductResponse extends z.infer<typeof UpdateExtensionBitsProductResponse> {}

export const GetExtensionsResponse = z.object({
  /**
   * A list that contains the specified extension.
   */
  "data": z.object({
    "allowlisted_config_urls": z.string().array(),
    "allowlisted_panel_urls": z.string().array(),
    "author_name": z.string(),
    "bits_enabled": z.boolean(),
    "can_install": z.boolean(),
    "configuration_location": z.enum(["hosted", "custom", "none"]),
    "description": z.string(),
    "eula_tos_url": z.string(),
    "has_chat_support": z.boolean(),
    "icon_url": z.string(),
    "icon_urls": z.object({
      "100x100": z.string().optional(),
      "24x24": z.string().optional(),
      "300x200": z.string().optional()
    }),
    "id": z.string(),
    "name": z.string(),
    "privacy_policy_url": z.string(),
    "request_identity_link": z.boolean(),
    "screenshot_urls": z.string().array(),
    "state": z.enum(["Approved", "AssetsUploaded", "Deleted", "Deprecated", "InReview", "InTest", "PendingAction", "Rejected", "Released"]),
    "subscriptions_support_level": z.enum(["none", "optional"]),
    "summary": z.string(),
    "support_email": z.string(),
    "version": z.string(),
    "viewer_summary": z.string(),
    "views": z.object({
      "component": z.object({
        "aspect_ratio_x": z.number(),
        "aspect_ratio_y": z.number(),
        "autoscale": z.boolean(),
        "can_link_external_content": z.boolean(),
        "scale_pixels": z.number(),
        "target_height": z.number(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * The width value of the ratio (width : height) which determines
         * the extension’s width, and how the extension’s iframe will
         * resize in different video player environments.
         */
        "aspectRatioX": it["aspect_ratio_x"],
        /**
         * The height value of the ratio (width : height) which determines
         * the extension’s height, and how the extension’s iframe will
         * resize in different video player environments.
         */
        "aspectRatioY": it["aspect_ratio_y"],
        /**
         * A Boolean value that determines whether to apply CSS zoom. If
         * **true**, a CSS zoom is applied such that the size of the
         * extension is variable but the inner dimensions are fixed based
         * on Scale Pixels. This allows your extension to render as if it
         * is of fixed width and height. If **false**, the inner
         * dimensions of the extension iframe are variable, meaning your
         * extension must implement responsiveness.
         */
        "autoscale": it["autoscale"],
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The base width, in pixels, of the extension to use when scaling
         * (see `autoscale`). This value is ignored if `autoscale` is
         * **false**.
         */
        "scalePixels": it["scale_pixels"],
        /**
         * The height as a percent of the maximum height of a video
         * component extension. Values are between 1% - 100%.
         */
        "targetHeight": it["target_height"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated in a Video - Component slot.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "config": z.object({
        "can_link_external_content": z.boolean(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The HTML file shown to broadcasters while they are configuring
         * your extension within the Extension Manager.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "mobile": z.object({
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * The HTML file that is shown to viewers on mobile devices. This
         * page is presented to viewers as a panel behind the chat area of
         * the mobile app.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "panel": z.object({
        "can_link_external_content": z.boolean(),
        "height": z.number(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The height, in pixels, of the panel component that the
         * extension is rendered in.
         */
        "height": it["height"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated in a Panel slot.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "video_overlay": z.object({
        "can_link_external_content": z.boolean(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated on the Video - Overlay slot.
         */
        "viewerUrl": it["viewer_url"],

      }))
    }).transform((it) => ({
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a video-component extension.
       */
      "component": it["component"],
      /**
       * Describes the view that is shown to broadcasters while they are
       * configuring your extension within the Extension Manager.
       */
      "config": it["config"],
      /**
       * Describes how the extension is displayed on mobile devices.
       */
      "mobile": it["mobile"],
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a panel extension.
       */
      "panel": it["panel"],
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a video-overlay extension.
       */
      "videoOverlay": it["video_overlay"],

    }))
  }).transform((it) => ({
    /**
     * Allowlisted configuration URLs for displaying the extension (the
     * allowlist is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \->
     * **Capabilities**).
     */
    "allowlistedConfigUrls": it["allowlisted_config_urls"],
    /**
     * Allowlisted panel URLs for displaying the extension (the allowlist
     * is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \->
     * **Capabilities**).
     */
    "allowlistedPanelUrls": it["allowlisted_panel_urls"],
    /**
     * The name of the user or organization that owns the extension.
     */
    "authorName": it["author_name"],
    /**
     * A Boolean value that determines whether the extension has features
     * that use Bits. Is **true** if the extension has features that use
     * Bits.
     */
    "bitsEnabled": it["bits_enabled"],
    /**
     * A Boolean value that determines whether a user can install the
     * extension on their channel. Is **true** if a user can install the
     * extension.  
     *   
     * Typically, this is set to **false** if the extension is currently
     * in testing mode and requires users to be allowlisted (the allowlist
     * is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \-> **Access**).
     */
    "canInstall": it["can_install"],
    /**
     * The location of where the extension’s configuration is stored.
     * Possible values are:  
     *   
     * * hosted — The Extensions Configuration Service hosts the
     * configuration.
     * * custom — The Extension Backend Service (EBS) hosts the
     * configuration.
     * * none — The extension doesn't require configuration.
     */
    "configurationLocation": it["configuration_location"],
    /**
     * A longer description of the extension. It appears on the details
     * page.
     */
    "description": it["description"],
    /**
     * A URL to the extension’s Terms of Service.
     */
    "eulaTosUrl": it["eula_tos_url"],
    /**
     * A Boolean value that determines whether the extension can
     * communicate with the installed channel’s chat. Is **true** if the
     * extension can communicate with the channel’s chat room.
     */
    "hasChatSupport": it["has_chat_support"],
    /**
     * A URL to the default icon that’s displayed in the Extensions
     * directory.
     */
    "iconUrl": it["icon_url"],
    /**
     * A dictionary that contains URLs to different sizes of the default
     * icon. The dictionary’s key identifies the icon’s size (for
     * example, 24x24), and the dictionary’s value contains the URL to
     * the icon.
     */
    "iconUrls": it["icon_urls"],
    /**
     * The extension’s ID.
     */
    "id": it["id"],
    /**
     * The extension’s name.
     */
    "name": it["name"],
    /**
     * A URL to the extension’s privacy policy.
     */
    "privacyPolicyUrl": it["privacy_policy_url"],
    /**
     * A Boolean value that determines whether the extension wants to
     * explicitly ask viewers to link their Twitch identity.
     */
    "requestIdentityLink": it["request_identity_link"],
    /**
     * A list of URLs to screenshots that are shown in the Extensions
     * marketplace.
     */
    "screenshotUrls": it["screenshot_urls"],
    /**
     * The extension’s state. Possible values are:  
     *   
     * * Approved
     * * AssetsUploaded
     * * Deleted
     * * Deprecated
     * * InReview
     * * InTest
     * * PendingAction
     * * Rejected
     * * Released
     */
    "state": it["state"],
    /**
     * Indicates whether the extension can view the user’s subscription
     * level on the channel that the extension is installed on. Possible
     * values are:  
     *   
     * * none — The extension can't view the user’s subscription
     * level.
     * * optional — The extension can view the user’s subscription
     * level.
     */
    "subscriptionsSupportLevel": it["subscriptions_support_level"],
    /**
     * A short description of the extension that streamers see when
     * hovering over the discovery splash screen in the Extensions
     * manager.
     */
    "summary": it["summary"],
    /**
     * The email address that users use to get support for the extension.
     */
    "supportEmail": it["support_email"],
    /**
     * The extension’s version number.
     */
    "version": it["version"],
    /**
     * A brief description displayed on the channel to explain how the
     * extension works.
     */
    "viewerSummary": it["viewer_summary"],
    /**
     * Describes all views-related information such as how the extension
     * is displayed on mobile devices.
     */
    "views": it["views"],

  })).array()
});
export interface GetExtensionsResponse extends z.infer<typeof GetExtensionsResponse> {}

export const GetExtensionConfigurationSegmentResponse = z.object({
  /**
   * The list of requested configuration segments. The list is returned in
   * the same order that you specified the list of segments in the
   * request.
   */
  "data": z.object({
    "broadcaster_id": z.string().optional(),
    "content": z.string(),
    "segment": z.enum(["broadcaster", "developer", "global"]),
    "version": z.string()
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that installed the extension. The object
     * includes this field only if the `segment` query parameter is set to
     * developer or broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The contents of the segment. This string may be a plain-text string
     * or a string-encoded JSON object.
     */
    "content": it["content"],
    /**
     * The type of segment. Possible values are:   
     *   
     * * broadcaster
     * * developer
     * * global
     */
    "segment": it["segment"],
    /**
     * The version number that identifies this definition of the
     * segment’s data.
     */
    "version": it["version"],

  })).array()
});
export interface GetExtensionConfigurationSegmentResponse extends z.infer<typeof GetExtensionConfigurationSegmentResponse> {}

export const GetExtensionSecretsResponse = z.object({
  /**
   * The list of shared secrets that the extension created.
   */
  "data": z.object({
    "format_version": z.number(),
    "secrets": z.object({
      "active_at": z.string(),
      "content": z.string(),
      "expires_at": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) that you may begin
       * using this secret to sign a JWT.
       */
      "activeAt": it["active_at"],
      /**
       * The raw secret that you use with JWT encoding.
       */
      "content": it["content"],
      /**
       * The UTC date and time (in RFC3339 format) that you must stop
       * using this secret to decode a JWT.
       */
      "expiresAt": it["expires_at"],

    })).array()
  }).transform((it) => ({
    /**
     * The version number that identifies this definition of the
     * secret’s data.
     */
    "formatVersion": it["format_version"],
    /**
     * The list of secrets.
     */
    "secrets": it["secrets"],

  })).array()
});
export interface GetExtensionSecretsResponse extends z.infer<typeof GetExtensionSecretsResponse> {}

export const CreateExtensionSecretResponse = z.object({
  /**
   * A list that contains the newly added secrets.
   */
  "data": z.object({
    "format_version": z.number(),
    "secrets": z.object({
      "active_at": z.string(),
      "content": z.string(),
      "expires_at": z.string()
    }).transform((it) => ({
      /**
       * The UTC date and time (in RFC3339 format) that you may begin
       * using this secret to sign a JWT.
       */
      "activeAt": it["active_at"],
      /**
       * The raw secret that you use with JWT encoding.
       */
      "content": it["content"],
      /**
       * The UTC date and time (in RFC3339 format) that you must stop
       * using this secret to decode a JWT.
       */
      "expiresAt": it["expires_at"],

    })).array()
  }).transform((it) => ({
    /**
     * The version number that identifies this definition of the
     * secret’s data.
     */
    "formatVersion": it["format_version"],
    /**
     * The list of secrets.
     */
    "secrets": it["secrets"],

  })).array()
});
export interface CreateExtensionSecretResponse extends z.infer<typeof CreateExtensionSecretResponse> {}

export const GetExtensionLiveChannelsResponse = z.object({
  /**
   * The list of broadcasters that are streaming live and that have
   * installed or activated the extension.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_name": z.string(),
    "game_id": z.string(),
    "game_name": z.string(),
    "title": z.string()
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that is streaming live and has installed
     * or activated the extension.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The ID of the category or game being streamed.
     */
    "gameId": it["game_id"],
    /**
     * The name of the category or game being streamed.
     */
    "gameName": it["game_name"],
    /**
     * The title of the broadcaster’s stream. May be an empty string if
     * not specified.
     */
    "title": it["title"],

  })).array(),
  /**
   * This field contains the cursor used to page through the results. The
   * field is empty if there are no more pages left to page through. Note
   * that this field is a string compared to other endpoints that use a
   * **Pagination** object. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.string().optional()
});
export interface GetExtensionLiveChannelsResponse extends z.infer<typeof GetExtensionLiveChannelsResponse> {}

export const GetReleasedExtensionsResponse = z.object({
  /**
   * A list that contains the specified extension.
   */
  "data": z.object({
    "allowlisted_config_urls": z.string().array(),
    "allowlisted_panel_urls": z.string().array(),
    "author_name": z.string(),
    "bits_enabled": z.boolean(),
    "can_install": z.boolean(),
    "configuration_location": z.enum(["hosted", "custom", "none"]),
    "description": z.string(),
    "eula_tos_url": z.string(),
    "has_chat_support": z.boolean(),
    "icon_url": z.string(),
    "icon_urls": z.object({
      "100x100": z.string().optional(),
      "24x24": z.string().optional(),
      "300x200": z.string().optional()
    }),
    "id": z.string(),
    "name": z.string(),
    "privacy_policy_url": z.string(),
    "request_identity_link": z.boolean(),
    "screenshot_urls": z.string().array(),
    "state": z.enum(["Approved", "AssetsUploaded", "Deleted", "Deprecated", "InReview", "InTest", "PendingAction", "Rejected", "Released"]),
    "subscriptions_support_level": z.enum(["none", "optional"]),
    "summary": z.string(),
    "support_email": z.string(),
    "version": z.string(),
    "viewer_summary": z.string(),
    "views": z.object({
      "component": z.object({
        "aspect_ratio_x": z.number(),
        "aspect_ratio_y": z.number(),
        "autoscale": z.boolean(),
        "can_link_external_content": z.boolean(),
        "scale_pixels": z.number(),
        "target_height": z.number(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * The width value of the ratio (width : height) which determines
         * the extension’s width, and how the extension’s iframe will
         * resize in different video player environments.
         */
        "aspectRatioX": it["aspect_ratio_x"],
        /**
         * The height value of the ratio (width : height) which determines
         * the extension’s height, and how the extension’s iframe will
         * resize in different video player environments.
         */
        "aspectRatioY": it["aspect_ratio_y"],
        /**
         * A Boolean value that determines whether to apply CSS zoom. If
         * **true**, a CSS zoom is applied such that the size of the
         * extension is variable but the inner dimensions are fixed based
         * on Scale Pixels. This allows your extension to render as if it
         * is of fixed width and height. If **false**, the inner
         * dimensions of the extension iframe are variable, meaning your
         * extension must implement responsiveness.
         */
        "autoscale": it["autoscale"],
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The base width, in pixels, of the extension to use when scaling
         * (see `autoscale`). This value is ignored if `autoscale` is
         * **false**.
         */
        "scalePixels": it["scale_pixels"],
        /**
         * The height as a percent of the maximum height of a video
         * component extension. Values are between 1% - 100%.
         */
        "targetHeight": it["target_height"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated in a Video - Component slot.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "config": z.object({
        "can_link_external_content": z.boolean(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The HTML file shown to broadcasters while they are configuring
         * your extension within the Extension Manager.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "mobile": z.object({
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * The HTML file that is shown to viewers on mobile devices. This
         * page is presented to viewers as a panel behind the chat area of
         * the mobile app.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "panel": z.object({
        "can_link_external_content": z.boolean(),
        "height": z.number(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The height, in pixels, of the panel component that the
         * extension is rendered in.
         */
        "height": it["height"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated in a Panel slot.
         */
        "viewerUrl": it["viewer_url"],

      })),
      "video_overlay": z.object({
        "can_link_external_content": z.boolean(),
        "viewer_url": z.string()
      }).transform((it) => ({
        /**
         * A Boolean value that determines whether the extension can link
         * to non-Twitch domains.
         */
        "canLinkExternalContent": it["can_link_external_content"],
        /**
         * The HTML file that is shown to viewers on the channel page when
         * the extension is activated on the Video - Overlay slot.
         */
        "viewerUrl": it["viewer_url"],

      }))
    }).transform((it) => ({
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a video-component extension.
       */
      "component": it["component"],
      /**
       * Describes the view that is shown to broadcasters while they are
       * configuring your extension within the Extension Manager.
       */
      "config": it["config"],
      /**
       * Describes how the extension is displayed on mobile devices.
       */
      "mobile": it["mobile"],
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a panel extension.
       */
      "panel": it["panel"],
      /**
       * Describes how the extension is rendered if the extension may be
       * activated as a video-overlay extension.
       */
      "videoOverlay": it["video_overlay"],

    }))
  }).transform((it) => ({
    /**
     * Allowlisted configuration URLs for displaying the extension (the
     * allowlist is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \->
     * **Capabilities**).
     */
    "allowlistedConfigUrls": it["allowlisted_config_urls"],
    /**
     * Allowlisted panel URLs for displaying the extension (the allowlist
     * is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \->
     * **Capabilities**).
     */
    "allowlistedPanelUrls": it["allowlisted_panel_urls"],
    /**
     * The name of the user or organization that owns the extension.
     */
    "authorName": it["author_name"],
    /**
     * A Boolean value that determines whether the extension has features
     * that use Bits. Is **true** if the extension has features that use
     * Bits.
     */
    "bitsEnabled": it["bits_enabled"],
    /**
     * A Boolean value that determines whether a user can install the
     * extension on their channel. Is **true** if a user can install the
     * extension.  
     *   
     * Typically, this is set to **false** if the extension is currently
     * in testing mode and requires users to be allowlisted (the allowlist
     * is configured on Twitch’s [developer
     * site](https://dev.twitch.tv/console/extensions) under the
     * **Extensions** \-> **Extension** \-> **Version** \-> **Access**).
     */
    "canInstall": it["can_install"],
    /**
     * The location of where the extension’s configuration is stored.
     * Possible values are:  
     *   
     * * hosted — The Extensions Configuration Service hosts the
     * configuration.
     * * custom — The Extension Backend Service (EBS) hosts the
     * configuration.
     * * none — The extension doesn't require configuration.
     */
    "configurationLocation": it["configuration_location"],
    /**
     * A longer description of the extension. It appears on the details
     * page.
     */
    "description": it["description"],
    /**
     * A URL to the extension’s Terms of Service.
     */
    "eulaTosUrl": it["eula_tos_url"],
    /**
     * A Boolean value that determines whether the extension can
     * communicate with the installed channel’s chat. Is **true** if the
     * extension can communicate with the channel’s chat room.
     */
    "hasChatSupport": it["has_chat_support"],
    /**
     * A URL to the default icon that’s displayed in the Extensions
     * directory.
     */
    "iconUrl": it["icon_url"],
    /**
     * A dictionary that contains URLs to different sizes of the default
     * icon. The dictionary’s key identifies the icon’s size (for
     * example, 24x24), and the dictionary’s value contains the URL to
     * the icon.
     */
    "iconUrls": it["icon_urls"],
    /**
     * The extension’s ID.
     */
    "id": it["id"],
    /**
     * The extension’s name.
     */
    "name": it["name"],
    /**
     * A URL to the extension’s privacy policy.
     */
    "privacyPolicyUrl": it["privacy_policy_url"],
    /**
     * A Boolean value that determines whether the extension wants to
     * explicitly ask viewers to link their Twitch identity.
     */
    "requestIdentityLink": it["request_identity_link"],
    /**
     * A list of URLs to screenshots that are shown in the Extensions
     * marketplace.
     */
    "screenshotUrls": it["screenshot_urls"],
    /**
     * The extension’s state. Possible values are:  
     *   
     * * Approved
     * * AssetsUploaded
     * * Deleted
     * * Deprecated
     * * InReview
     * * InTest
     * * PendingAction
     * * Rejected
     * * Released
     */
    "state": it["state"],
    /**
     * Indicates whether the extension can view the user’s subscription
     * level on the channel that the extension is installed on. Possible
     * values are:  
     *   
     * * none — The extension can't view the user’s subscription
     * level.
     * * optional — The extension can view the user’s subscription
     * level.
     */
    "subscriptionsSupportLevel": it["subscriptions_support_level"],
    /**
     * A short description of the extension that streamers see when
     * hovering over the discovery splash screen in the Extensions
     * manager.
     */
    "summary": it["summary"],
    /**
     * The email address that users use to get support for the extension.
     */
    "supportEmail": it["support_email"],
    /**
     * The extension’s version number.
     */
    "version": it["version"],
    /**
     * A brief description displayed on the channel to explain how the
     * extension works.
     */
    "viewerSummary": it["viewer_summary"],
    /**
     * Describes all views-related information such as how the extension
     * is displayed on mobile devices.
     */
    "views": it["views"],

  })).array()
});
export interface GetReleasedExtensionsResponse extends z.infer<typeof GetReleasedExtensionsResponse> {}



export class Extensions {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets the list of Bits products that belongs to the extension. The client
   * ID in the app access token identifies the extension.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The
   * client ID in the app access token must be the extension’s client ID.
   */
  async getExtensionBitsProducts(options: GetExtensionBitsProductsRequest): Promise<GetExtensionBitsProductsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/bits/extensions", this.#twitch.base);
    if (options.shouldIncludeAll) {
      url.searchParams.append("should_include_all", options.shouldIncludeAll.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionBitsProductsResponse);
  }
  /**
   * Adds or updates a Bits product that the extension created. If the SKU
   * doesn’t exist, the product is added. You may update all fields except
   * the `sku` field.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The
   * client ID in the app access token must match the extension’s client ID.
   */
  async updateExtensionBitsProduct(options: UpdateExtensionBitsProductRequest): Promise<UpdateExtensionBitsProductResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/bits/extensions", this.#twitch.base);
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.expiration = options.expiration;
    body.is_broadcast = options.isBroadcast;
    body.cost = options.cost;
    body.in_development = options.inDevelopment;
    body.sku = options.sku;
    body.display_name = options.displayName;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateExtensionBitsProductResponse);
  }
  /**
   * Gets information about an extension.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role` field (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and
   * the `role` field must be set to _external_.
   */
  async getExtensions(options: GetExtensionsRequest): Promise<GetExtensionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions", this.#twitch.base);
    if (options.extensionVersion) {
      url.searchParams.append("extension_version", options.extensionVersion.toString());
    }
    url.searchParams.append("extension_id", options.extensionId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionsResponse);
  }
  /**
   * Sends a message to the specified broadcaster’s chat room. The
   * extension’s name is used as the username for the message in the chat
   * room. To send a chat message, your extension must enable **Chat
   * Capabilities** (under your extension’s **Capabilities** tab).
   * 
   * **Rate Limits**: You may send a maximum of 12 messages per minute per
   * channel.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role` and `user_id` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The
   * `role` field must be set to _external_.
   */
  async sendExtensionChatMessage(options: SendExtensionChatMessageRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/chat", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.text = options.text;
    body.extension_version = options.extensionVersion;
    body.extension_id = options.extensionId;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the specified configuration segment from the specified extension.
   * 
   * **Rate Limits**: You may retrieve each segment a maximum of 20 times per
   * minute.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The
   * `role` field must be set to _external_.
   */
  async getExtensionConfigurationSegment(options: GetExtensionConfigurationSegmentRequest): Promise<GetExtensionConfigurationSegmentResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/configurations", this.#twitch.base);
    if (options.broadcasterId) {
      url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    }
    url.searchParams.append("extension_id", options.extensionId.toString());
    url.searchParams.append("segment", options.segment.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionConfigurationSegmentResponse);
  }
  /**
   * Updates a configuration segment. The segment is limited to 5 KB.
   * Extensions that are active on a channel do not receive the updated
   * configuration.
   * 
   * **Rate Limits**: You may update the configuration a maximum of 20 times
   * per minute.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The
   * `role` field must be set to _external_.
   */
  async setExtensionConfigurationSegment(options: SetExtensionConfigurationSegmentRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/configurations", this.#twitch.base);
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.broadcaster_id = options.broadcasterId;
    body.content = options.content;
    body.extension_id = options.extensionId;
    body.segment = options.segment;
    body.version = options.version;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets an extension’s list of shared secrets.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The
   * `role` field must be set to _external_.
   */
  async getExtensionSecrets(): Promise<GetExtensionSecretsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/jwt/secrets", this.#twitch.base);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionSecretsResponse);
  }
  /**
   * Creates a shared secret used to sign and verify JWT tokens. Creating a new
   * secret removes the current secrets from service. Use this function only
   * when you are ready to use the new secret it returns.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The
   * `role` field must be set to _external_.
   */
  async createExtensionSecret(options: CreateExtensionSecretRequest): Promise<CreateExtensionSecretResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/jwt/secrets", this.#twitch.base);
    if (options.delay) {
      url.searchParams.append("delay", options.delay.toString());
    }
    url.searchParams.append("extension_id", options.extensionId.toString());
    const opts: RequestInit = { method: 'POST' };

    return await this.#twitch.request(url, opts, CreateExtensionSecretResponse);
  }
  /**
   * Gets a list of broadcasters that are streaming live and have installed or
   * activated the extension.
   * 
   * It may take a few minutes for the list to include or remove broadcasters
   * that have recently gone live or stopped broadcasting.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getExtensionLiveChannels(options: GetExtensionLiveChannelsRequest): Promise<GetExtensionLiveChannelsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/live", this.#twitch.base);
    url.searchParams.append("extension_id", options.extensionId.toString());
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionLiveChannelsResponse);
  }
  /**
   * Sends a message to one or more viewers. You can send messages to a
   * specific channel or to all channels where your extension is active. This
   * endpoint uses the same mechanism as the
   * [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript
   * helper function used to send messages.
   * 
   * **Rate Limits**: You may send a maximum of 100 messages per minute per
   * combination of extension client ID and broadcaster ID.
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an Extension Backend
   * Service (EBS). For signing requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema))
   * along with the `channel_id` and `pubsub_perms` fields. The `role` field
   * must be set to _external_.
   * 
   * To send the message to a specific channel, set the `channel_id` field in
   * the JWT to the channel’s ID and set the `pubsub_perms.send` array to
   * _broadcast_.
   * 
   * ```
   * {
   *   "exp": 1503343947,
   *   "user_id": "27419011",
   *   "role": "external",
   *   "channel_id": "27419011",
   *   "pubsub_perms": {
   *     "send":[
   *       "broadcast"
   *     ]
   *   }
   * }
   * 
   * ```
   * 
   * To send the message to all channels on which your extension is active, set
   * the `channel_id` field to _all_ and set the `pubsub_perms.send` array to
   * _global_.
   * 
   * ```
   * {
   *   "exp": 1503343947,
   *   "user_id": "27419011",
   *   "role": "external",
   *   "channel_id": "all",
   *   "pubsub_perms": {
   *     "send":[
   *       "global"
   *     ]
   *   }
   * }
   * 
   * ```
   */
  async sendExtensionPubsubMessage(options: SendExtensionPubsubMessageRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/pubsub", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.is_global_broadcast = options.isGlobalBroadcast;
    body.broadcaster_id = options.broadcasterId;
    body.message = options.message;
    body.target = options.target;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets information about a released extension. Returns the extension if its
   * `state` is Released.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getReleasedExtensions(options: GetReleasedExtensionsRequest): Promise<GetReleasedExtensionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/released", this.#twitch.base);
    if (options.extensionVersion) {
      url.searchParams.append("extension_version", options.extensionVersion.toString());
    }
    url.searchParams.append("extension_id", options.extensionId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetReleasedExtensionsResponse);
  }
  /**
   * Updates the extension’s required\_configuration string. Use this
   * endpoint if your extension requires the broadcaster to configure the
   * extension before activating it (to require configuration, you must select
   * **Custom/My Own Service** in Extension
   * [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). 
   * For more information, see [Required
   * Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) 
   * and [Setting Required
   * Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).
   * 
   * __Authorization:__
   * 
   * Requires a signed JSON Web Token (JWT) created by an EBS. For signing
   * requirements, see [Signing the
   * JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The
   * signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT
   * Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set
   * the `role` field to _external_ and the `user_id` field to the ID of the
   * user that owns the extension.
   */
  async setExtensionRequiredConfiguration(options: SetExtensionRequiredConfigurationRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/required_configuration", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.extension_id = options.extensionId;
    body.extension_version = options.extensionVersion;
    body.required_configuration = options.requiredConfiguration;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
}
