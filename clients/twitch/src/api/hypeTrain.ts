
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetHypeTrainEventsRequest {
  /**
   * The ID of the broadcaster that’s running the Hype Train. This ID must
   * match the User ID in the user access token.
   */
  broadcasterId: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 1.
   */
  first?: number,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
}
export const GetHypeTrainEventsResponse = z.object({
  /**
   * The list of Hype Train events. The list is empty if the broadcaster
   * hasn’t run a Hype Train within the last 5 days.
   */
  "data": z.object({
    "event_data": z.object({
      "broadcaster_id": z.string(),
      "cooldown_end_time": z.string(),
      "expires_at": z.string(),
      "goal": z.number(),
      "id": z.string(),
      "last_contribution": z.object({
        /**
         * The total amount contributed. If `type` is BITS, `total`
         * represents the amount of Bits used. If `type` is SUBS, `total`
         * is 500, 1000, or 2500 to represent tier 1, 2, or 3
         * subscriptions, respectively.
         */
        "total": z.number(),
        /**
         * The contribution method used. Possible values are:  
         *   
         * * BITS — Cheering with Bits.
         * * SUBS — Subscription activity like subscribing or gifting
         * subscriptions.
         * * OTHER — Covers other contribution methods not listed.
         */
        "type": z.enum(["BITS", "SUBS", "OTHER"]),
        /**
         * The ID of the user that made the contribution.
         */
        "user": z.string()
      }),
      "level": z.number(),
      "started_at": z.string(),
      "top_contributions": z.object({
        /**
         * The total amount contributed. If `type` is BITS, `total`
         * represents the amount of Bits used. If `type` is SUBS, `total`
         * is 500, 1000, or 2500 to represent tier 1, 2, or 3
         * subscriptions, respectively.
         */
        "total": z.number(),
        /**
         * The contribution method used. Possible values are:  
         *   
         * * BITS — Cheering with Bits.
         * * SUBS — Subscription activity like subscribing or gifting
         * subscriptions.
         * * OTHER — Covers other contribution methods not listed.
         */
        "type": z.enum(["BITS", "SUBS", "OTHER"]),
        /**
         * The ID of the user that made the contribution.
         */
        "user": z.string()
      }).array(),
      "total": z.number()
    }).transform((it) => ({
      /**
       * The ID of the broadcaster that’s running the Hype Train.
       */
      "broadcasterId": it["broadcaster_id"],
      /**
       * The UTC date and time (in RFC3339 format) that another Hype Train
       * can start.
       */
      "cooldownEndTime": it["cooldown_end_time"],
      /**
       * The UTC date and time (in RFC3339 format) that the Hype Train
       * ends.
       */
      "expiresAt": it["expires_at"],
      /**
       * The value needed to reach the next level.
       */
      "goal": it["goal"],
      /**
       * An ID that identifies this Hype Train.
       */
      "id": it["id"],
      /**
       * The most recent contribution towards the Hype Train’s goal.
       */
      "lastContribution": it["last_contribution"],
      /**
       * The highest level that the Hype Train reached (the levels are 1
       * through 5).
       */
      "level": it["level"],
      /**
       * The UTC date and time (in RFC3339 format) that this Hype Train
       * started.
       */
      "startedAt": it["started_at"],
      /**
       * The top contributors for each contribution type. For example, the
       * top contributor using BITS (by aggregate) and the top contributor
       * using SUBS (by count).
       */
      "topContributions": it["top_contributions"],
      /**
       * The current total amount raised.
       */
      "total": it["total"],

    })),
    "event_timestamp": z.string(),
    "event_type": z.string(),
    "id": z.string(),
    "version": z.string()
  }).transform((it) => ({
    /**
     * The event’s data.
     */
    "eventData": it["event_data"],
    /**
     * The UTC date and time (in RFC3339 format) that the event occurred.
     */
    "eventTimestamp": it["event_timestamp"],
    /**
     * The type of event. The string is in the form,
     * hypetrain.{event\_name}. The request returns only progress event
     * types (i.e., hypetrain.progression).
     */
    "eventType": it["event_type"],
    /**
     * An ID that identifies this event.
     */
    "id": it["id"],
    /**
     * The version number of the definition of the event’s data. For
     * example, the value is 1 if the data in `event_data` uses the first
     * definition of the event’s data.
     */
    "version": it["version"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetHypeTrainEventsResponse extends z.infer<typeof GetHypeTrainEventsResponse> {}



export class HypeTrain {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets information about the broadcaster’s current or most recent Hype
   * Train event.
   * 
   * Instead of polling for events, consider
   * [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to
   * Hype Train events
   * ([Begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainbegin), 
   * [Progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainprogress), 
   * [End](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainend)).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:hype\_train** scope.
   */
  async getHypeTrainEvents(options: GetHypeTrainEventsRequest): Promise<GetHypeTrainEventsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/hypetrain/events", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetHypeTrainEventsResponse);
  }
}
