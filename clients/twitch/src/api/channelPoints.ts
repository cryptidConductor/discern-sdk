
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetCustomRewardRequest {
  /**
   * A list of IDs to filter the rewards by. To specify more than one ID,
   * include this parameter for each reward you want to get. For example,
   * `id=1234&id=5678`. You may specify a maximum of 50 IDs.  
   *   
   * Duplicate IDs are ignored. The response contains only the IDs that were
   * found. If none of the IDs were found, the response is 404 Not Found.
   */
  id?: string[],
  /**
   * The ID of the broadcaster whose custom rewards you want to get. This ID
   * must match the user ID found in the OAuth token.
   */
  broadcasterId: string,
  /**
   * A Boolean value that determines whether the response contains only the
   * custom rewards that the app may manage (the app is identified by the ID in
   * the Client-Id header). Set to **true** to get only the custom rewards that
   * the app may manage. The default is **false**.
   */
  onlyManageableRewards?: boolean,
}
export interface CreateCustomRewardsRequest {
  /**
   * The background color to use for the reward. Specify the color using Hex
   * format (for example, #9147FF).
   */
  backgroundColor?: string,
  /**
   * The cost of the reward, in Channel Points. The minimum is 1 point.
   */
  cost: number,
  /**
   * The maximum number of redemptions allowed per user per stream. Applied
   * only if `is_max_per_user_per_stream_enabled` is **true**. The minimum
   * value is 1.
   */
  maxPerUserPerStream?: number,
  /**
   * The prompt shown to the viewer when they redeem the reward. Specify a
   * prompt if `is_user_input_required` is **true**. The prompt is limited to a
   * maximum of 200 characters.
   */
  prompt?: string,
  /**
   * A Boolean value that determines whether to limit the maximum number of
   * redemptions allowed per user per stream (see the `max_per_user_per_stream`
   * field). The default is **false**.
   */
  isMaxPerUserPerStreamEnabled?: boolean,
  /**
   * The maximum number of redemptions allowed per live stream. Applied only if
   * `is_max_per_stream_enabled` is **true**. The minimum value is 1.
   */
  maxPerStream?: number,
  /**
   * A Boolean value that determines whether to apply a cooldown period between
   * redemptions (see the `global_cooldown_seconds` field for the duration of
   * the cooldown period). The default is **false**.
   */
  isGlobalCooldownEnabled?: boolean,
  /**
   * A Boolean value that determines whether the user needs to enter
   * information when redeeming the reward. See the `prompt` field. The default
   * is **false**.
   */
  isUserInputRequired?: boolean,
  /**
   * A Boolean value that determines whether to limit the maximum number of
   * redemptions allowed per live stream (see the `max_per_stream` field). The
   * default is **false**.
   */
  isMaxPerStreamEnabled?: boolean,
  /**
   * A Boolean value that determines whether the reward is enabled. Viewers see
   * only enabled rewards. The default is **true**.
   */
  isEnabled?: boolean,
  /**
   * A Boolean value that determines whether redemptions should be set to
   * FULFILLED status immediately when a reward is redeemed. If **false**,
   * status is set to UNFULFILLED and follows the normal request queue process.
   * The default is **false**.
   */
  shouldRedemptionsSkipRequestQueue?: boolean,
  /**
   * The ID of the broadcaster to add the custom reward to. This ID must match
   * the user ID found in the OAuth token.
   */
  broadcasterId: string,
  /**
   * The cooldown period, in seconds. Applied only if the
   * `is_global_cooldown_enabled` field is **true**. The minimum value is 1;
   * however, the minimum value is 60 for it to be shown in the Twitch UX.
   */
  globalCooldownSeconds?: number,
  /**
   * The custom reward’s title. The title may contain a maximum of 45
   * characters and it must be unique amongst all of the broadcaster’s custom
   * rewards.
   */
  title: string,
}
export interface DeleteCustomRewardRequest {
  /**
   * The ID of the broadcaster that created the custom reward. This ID must
   * match the user ID found in the OAuth token.
   */
  broadcasterId: string,
  /**
   * The ID of the custom reward to delete.
   */
  id: string,
}
export interface UpdateCustomRewardRequest {
  /**
   * The ID of the broadcaster that’s updating the reward. This ID must match
   * the user ID found in the OAuth token.
   */
  broadcasterId: string,
  /**
   * The ID of the reward to update.
   */
  id: string,
  /**
   * The cooldown period, in seconds. Applied only if
   * `is_global_cooldown_enabled` is **true**. The minimum value is 1; however,
   * for it to be shown in the Twitch UX, the minimum value is 60.
   */
  globalCooldownSeconds?: number,
  /**
   * A Boolean value that determines whether to limit the maximum number of
   * redemptions allowed per user per stream (see `max_per_user_per_stream`).
   * The minimum value is 1\. Set to **true** to limit redemptions.
   */
  isMaxPerUserPerStreamEnabled?: boolean,
  /**
   * A Boolean value that determines whether to limit the maximum number of
   * redemptions allowed per live stream (see the `max_per_stream` field). Set
   * to **true** to limit redemptions.
   */
  isMaxPerStreamEnabled?: boolean,
  /**
   * A Boolean value that indicates whether the reward is enabled. Set to
   * **true** to enable the reward. Viewers see only enabled rewards.
   */
  isEnabled?: boolean,
  /**
   * The background color to use for the reward. Specify the color using Hex
   * format (for example, \\#00E5CB).
   */
  backgroundColor?: string,
  /**
   * The maximum number of redemptions allowed per live stream. Applied only if
   * `is_max_per_stream_enabled` is **true**. The minimum value is 1.
   */
  maxPerStream?: number,
  /**
   * The maximum number of redemptions allowed per user per stream. Applied
   * only if `is_max_per_user_per_stream_enabled` is **true**.
   */
  maxPerUserPerStream?: number,
  /**
   * A Boolean value that determines whether to apply a cooldown period between
   * redemptions. Set to **true** to apply a cooldown period. For the duration
   * of the cooldown period, see `global_cooldown_seconds`.
   */
  isGlobalCooldownEnabled?: boolean,
  /**
   * A Boolean value that determines whether redemptions should be set to
   * FULFILLED status immediately when a reward is redeemed. If **false**,
   * status is set to UNFULFILLED and follows the normal request queue process.
   */
  shouldRedemptionsSkipRequestQueue?: boolean,
  /**
   * The prompt shown to the viewer when they redeem the reward. Specify a
   * prompt if `is_user_input_required` is **true**. The prompt is limited to a
   * maximum of 200 characters.
   */
  prompt?: string,
  /**
   * The cost of the reward, in channel points. The minimum is 1 point.
   */
  cost?: number,
  /**
   * The reward’s title. The title may contain a maximum of 45 characters and
   * it must be unique amongst all of the broadcaster’s custom rewards.
   */
  title?: string,
  /**
   * A Boolean value that determines whether to pause the reward. Set to
   * **true** to pause the reward. Viewers can’t redeem paused rewards..
   */
  isPaused?: boolean,
  /**
   * A Boolean value that determines whether users must enter information to
   * redeem the reward. Set to **true** if user input is required. See the
   * `prompt` field.
   */
  isUserInputRequired?: boolean,
}
export interface GetCustomRewardRedemptionRequest {
  /**
   * The ID of the broadcaster that owns the custom reward. This ID must match
   * the user ID found in the user OAuth token.
   */
  broadcasterId: string,
  /**
   * A list of IDs to filter the redemptions by. To specify more than one ID,
   * include this parameter for each redemption you want to get. For example,
   * `id=1234&id=5678`. You may specify a maximum of 50 IDs.  
   *   
   * Duplicate IDs are ignored. The response contains only the IDs that were
   * found. If none of the IDs were found, the response is 404 Not Found.
   */
  id?: string[],
  /**
   * The ID that identifies the custom reward whose redemptions you want to
   * get.
   */
  rewardId: string,
  /**
   * The order to sort redemptions by. The possible case-sensitive values are:
   * 
   *   
   * * OLDEST
   * * NEWEST
   *   
   * The default is OLDEST.
   */
  sort?: | "OLDEST"| "NEWEST",
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * more](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The status of the redemptions to return. The possible case-sensitive
   * values are:  
   *   
   * * CANCELED
   * * FULFILLED
   * * UNFULFILLED
   *   
   * **NOTE**: This field is required only if you don’t specify the _id_
   * query parameter.  
   *   
   * **NOTE**: Canceled and fulfilled redemptions are returned for only a few
   * days after they’re canceled or fulfilled.
   */
  status?: | "CANCELED"| "FULFILLED"| "UNFULFILLED",
  /**
   * The maximum number of redemptions to return per page in the response. The
   * minimum page size is 1 redemption per page and the maximum is 50\. The
   * default is 20.
   */
  first?: number,
}
export interface UpdateRedemptionStatusRequest {
  /**
   * A list of IDs that identify the redemptions to update. To specify more
   * than one ID, include this parameter for each redemption you want to
   * update. For example, `id=1234&id=5678`. You may specify a maximum of 50
   * IDs.
   */
  id: string[],
  /**
   * The ID that identifies the reward that’s been redeemed.
   */
  rewardId: string,
  /**
   * The status to set the redemption to. Possible values are:  
   *   
   * * CANCELED
   * * FULFILLED
   *   
   * Setting the status to CANCELED refunds the user’s channel points.
   */
  status: | "CANCELED"| "FULFILLED",
}
export const GetCustomRewardResponse = z.object({
  /**
   * A list of custom rewards. The list is in ascending order by `id`. If
   * the broadcaster hasn’t created custom rewards, the list is empty.
   */
  "data": z.object({
    "background_color": z.string(),
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "cooldown_expires_at": z.string(),
    "cost": z.number(),
    "default_image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "global_cooldown_setting": z.object({
      "global_cooldown_seconds": z.number(),
      "is_enabled": z.boolean()
    }).transform((it) => ({
      /**
       * The cooldown period, in seconds.
       */
      "globalCooldownSeconds": it["global_cooldown_seconds"],
      /**
       * A Boolean value that determines whether to apply a cooldown
       * period. Is **true** if a cooldown period is enabled.
       */
      "isEnabled": it["is_enabled"],

    })),
    "id": z.string(),
    "image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "is_enabled": z.boolean(),
    "is_in_stock": z.boolean(),
    "is_paused": z.boolean(),
    "is_user_input_required": z.boolean(),
    "max_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per live stream. Is
       * **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per live stream.
       */
      "maxPerStream": it["max_per_stream"],

    })),
    "max_per_user_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_user_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per user per live
       * stream. Is **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per user per live
       * stream.
       */
      "maxPerUserPerStream": it["max_per_user_per_stream"],

    })),
    "prompt": z.string(),
    "redemptions_redeemed_current_stream": z.number(),
    "should_redemptions_skip_request_queue": z.boolean(),
    "title": z.string()
  }).transform((it) => ({
    /**
     * The background color to use for the reward. The color is in Hex
     * format (for example, #00E5CB).
     */
    "backgroundColor": it["background_color"],
    /**
     * The ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The timestamp of when the cooldown period expires. Is **null** if
     * the reward isn’t in a cooldown state. See the
     * `global_cooldown_setting` field.
     */
    "cooldownExpiresAt": it["cooldown_expires_at"],
    /**
     * The cost of the reward in Channel Points.
     */
    "cost": it["cost"],
    /**
     * A set of default images for the reward.
     */
    "defaultImage": it["default_image"],
    /**
     * The settings used to determine whether to apply a cooldown period
     * between redemptions and the length of the cooldown.
     */
    "globalCooldownSetting": it["global_cooldown_setting"],
    /**
     * The ID that uniquely identifies this custom reward.
     */
    "id": it["id"],
    /**
     * A set of custom images for the reward. This field is **null** if
     * the broadcaster didn’t upload images.
     */
    "image": it["image"],
    /**
     * A Boolean value that determines whether the reward is enabled. Is
     * **true** if enabled; otherwise, **false**. Disabled rewards
     * aren’t shown to the user.
     */
    "isEnabled": it["is_enabled"],
    /**
     * A Boolean value that determines whether the reward is currently in
     * stock. Is **true** if the reward is in stock. Viewers can’t
     * redeem out of stock rewards.
     */
    "isInStock": it["is_in_stock"],
    /**
     * A Boolean value that determines whether the reward is currently
     * paused. Is **true** if the reward is paused. Viewers can’t redeem
     * paused rewards.
     */
    "isPaused": it["is_paused"],
    /**
     * A Boolean value that determines whether the user must enter
     * information when they redeem the reward. Is **true** if the user is
     * prompted.
     */
    "isUserInputRequired": it["is_user_input_required"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per live stream.
     */
    "maxPerStreamSetting": it["max_per_stream_setting"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per user per live stream.
     */
    "maxPerUserPerStreamSetting": it["max_per_user_per_stream_setting"],
    /**
     * The prompt shown to the viewer when they redeem the reward if user
     * input is required. See the `is_user_input_required` field.
     */
    "prompt": it["prompt"],
    /**
     * The number of redemptions redeemed during the current live stream.
     * The number counts against the `max_per_stream_setting` limit. This
     * field is **null** if the broadcaster’s stream isn’t live or
     * _max\_per\_stream\_setting_ isn’t enabled.
     */
    "redemptionsRedeemedCurrentStream": it["redemptions_redeemed_current_stream"],
    /**
     * A Boolean value that determines whether redemptions should be set
     * to FULFILLED status immediately when a reward is redeemed. If
     * **false**, status is set to UNFULFILLED and follows the normal
     * request queue process.
     */
    "shouldRedemptionsSkipRequestQueue": it["should_redemptions_skip_request_queue"],
    /**
     * The title of the reward.
     */
    "title": it["title"],

  })).array()
});
export interface GetCustomRewardResponse extends z.infer<typeof GetCustomRewardResponse> {}

export const CreateCustomRewardsResponse = z.object({
  /**
   * A list that contains the single custom reward you created.
   */
  "data": z.object({
    "background_color": z.string(),
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "cooldown_expires_at": z.string(),
    "cost": z.number(),
    "default_image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "global_cooldown_setting": z.object({
      "global_cooldown_seconds": z.number(),
      "is_enabled": z.boolean()
    }).transform((it) => ({
      /**
       * The cooldown period, in seconds.
       */
      "globalCooldownSeconds": it["global_cooldown_seconds"],
      /**
       * A Boolean value that determines whether to apply a cooldown
       * period. Is **true** if a cooldown period is enabled.
       */
      "isEnabled": it["is_enabled"],

    })),
    "id": z.string(),
    "image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "is_enabled": z.boolean(),
    "is_in_stock": z.boolean(),
    "is_paused": z.boolean(),
    "is_user_input_required": z.boolean(),
    "max_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per live stream. Is
       * **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per live stream.
       */
      "maxPerStream": it["max_per_stream"],

    })),
    "max_per_user_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_user_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per user per live
       * stream. Is **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per user per live
       * stream.
       */
      "maxPerUserPerStream": it["max_per_user_per_stream"],

    })),
    "prompt": z.string(),
    "redemptions_redeemed_current_stream": z.number(),
    "should_redemptions_skip_request_queue": z.boolean(),
    "title": z.string()
  }).transform((it) => ({
    /**
     * The background color to use for the reward. The color is in Hex
     * format (for example, #00E5CB).
     */
    "backgroundColor": it["background_color"],
    /**
     * The ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The timestamp of when the cooldown period expires. Is **null** if
     * the reward isn’t in a cooldown state. See the
     * `global_cooldown_setting` field.
     */
    "cooldownExpiresAt": it["cooldown_expires_at"],
    /**
     * The cost of the reward in Channel Points.
     */
    "cost": it["cost"],
    /**
     * A set of default images for the reward.
     */
    "defaultImage": it["default_image"],
    /**
     * The settings used to determine whether to apply a cooldown period
     * between redemptions and the length of the cooldown.
     */
    "globalCooldownSetting": it["global_cooldown_setting"],
    /**
     * The ID that uniquely identifies this custom reward.
     */
    "id": it["id"],
    /**
     * A set of custom images for the reward. This field is **null** if
     * the broadcaster didn’t upload images.
     */
    "image": it["image"],
    /**
     * A Boolean value that determines whether the reward is enabled. Is
     * **true** if enabled; otherwise, **false**. Disabled rewards
     * aren’t shown to the user.
     */
    "isEnabled": it["is_enabled"],
    /**
     * A Boolean value that determines whether the reward is currently in
     * stock. Is **true** if the reward is in stock. Viewers can’t
     * redeem out of stock rewards.
     */
    "isInStock": it["is_in_stock"],
    /**
     * A Boolean value that determines whether the reward is currently
     * paused. Is **true** if the reward is paused. Viewers can’t redeem
     * paused rewards.
     */
    "isPaused": it["is_paused"],
    /**
     * A Boolean value that determines whether the user must enter
     * information when they redeem the reward. Is **true** if the user is
     * prompted.
     */
    "isUserInputRequired": it["is_user_input_required"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per live stream.
     */
    "maxPerStreamSetting": it["max_per_stream_setting"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per user per live stream.
     */
    "maxPerUserPerStreamSetting": it["max_per_user_per_stream_setting"],
    /**
     * The prompt shown to the viewer when they redeem the reward if user
     * input is required. See the `is_user_input_required` field.
     */
    "prompt": it["prompt"],
    /**
     * The number of redemptions redeemed during the current live stream.
     * The number counts against the `max_per_stream_setting` limit. This
     * field is **null** if the broadcaster’s stream isn’t live or
     * _max\_per\_stream\_setting_ isn’t enabled.
     */
    "redemptionsRedeemedCurrentStream": it["redemptions_redeemed_current_stream"],
    /**
     * A Boolean value that determines whether redemptions should be set
     * to FULFILLED status immediately when a reward is redeemed. If
     * **false**, status is set to UNFULFILLED and follows the normal
     * request queue process.
     */
    "shouldRedemptionsSkipRequestQueue": it["should_redemptions_skip_request_queue"],
    /**
     * The title of the reward.
     */
    "title": it["title"],

  })).array()
});
export interface CreateCustomRewardsResponse extends z.infer<typeof CreateCustomRewardsResponse> {}

export const UpdateCustomRewardResponse = z.object({
  /**
   * The list contains the single reward that you updated.
   */
  "data": z.object({
    "background_color": z.string(),
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "cooldown_expires_at": z.string(),
    "cost": z.number(),
    "default_image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "global_cooldown_setting": z.object({
      "global_cooldown_seconds": z.number(),
      "is_enabled": z.boolean()
    }).transform((it) => ({
      /**
       * The cooldown period, in seconds.
       */
      "globalCooldownSeconds": it["global_cooldown_seconds"],
      /**
       * A Boolean value that determines whether to apply a cooldown
       * period. Is **true** if a cooldown period is enabled.
       */
      "isEnabled": it["is_enabled"],

    })),
    "id": z.string(),
    "image": z.object({
      "url_1x": z.string(),
      "url_2x": z.string(),
      "url_4x": z.string()
    }).transform((it) => ({
      /**
       * The URL to a small version of the image.
       */
      "url1x": it["url_1x"],
      /**
       * The URL to a medium version of the image.
       */
      "url2x": it["url_2x"],
      /**
       * The URL to a large version of the image.
       */
      "url4x": it["url_4x"],

    })),
    "is_enabled": z.boolean(),
    "is_in_stock": z.boolean(),
    "is_paused": z.boolean(),
    "is_user_input_required": z.boolean(),
    "max_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per live stream. Is
       * **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per live stream.
       */
      "maxPerStream": it["max_per_stream"],

    })),
    "max_per_user_per_stream_setting": z.object({
      "is_enabled": z.boolean(),
      "max_per_user_per_stream": z.number()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether the reward applies a
       * limit on the number of redemptions allowed per user per live
       * stream. Is **true** if the reward applies a limit.
       */
      "isEnabled": it["is_enabled"],
      /**
       * The maximum number of redemptions allowed per user per live
       * stream.
       */
      "maxPerUserPerStream": it["max_per_user_per_stream"],

    })),
    "prompt": z.string(),
    "redemptions_redeemed_current_stream": z.number(),
    "should_redemptions_skip_request_queue": z.boolean(),
    "title": z.string()
  }).transform((it) => ({
    /**
     * The background color to use for the reward. The color is in Hex
     * format (for example, #00E5CB).
     */
    "backgroundColor": it["background_color"],
    /**
     * The ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The timestamp of when the cooldown period expires. Is **null** if
     * the reward isn’t in a cooldown state. See the
     * `global_cooldown_setting` field.
     */
    "cooldownExpiresAt": it["cooldown_expires_at"],
    /**
     * The cost of the reward in Channel Points.
     */
    "cost": it["cost"],
    /**
     * A set of default images for the reward.
     */
    "defaultImage": it["default_image"],
    /**
     * The settings used to determine whether to apply a cooldown period
     * between redemptions and the length of the cooldown.
     */
    "globalCooldownSetting": it["global_cooldown_setting"],
    /**
     * The ID that uniquely identifies this custom reward.
     */
    "id": it["id"],
    /**
     * A set of custom images for the reward. This field is **null** if
     * the broadcaster didn’t upload images.
     */
    "image": it["image"],
    /**
     * A Boolean value that determines whether the reward is enabled. Is
     * **true** if enabled; otherwise, **false**. Disabled rewards
     * aren’t shown to the user.
     */
    "isEnabled": it["is_enabled"],
    /**
     * A Boolean value that determines whether the reward is currently in
     * stock. Is **true** if the reward is in stock. Viewers can’t
     * redeem out of stock rewards.
     */
    "isInStock": it["is_in_stock"],
    /**
     * A Boolean value that determines whether the reward is currently
     * paused. Is **true** if the reward is paused. Viewers can’t redeem
     * paused rewards.
     */
    "isPaused": it["is_paused"],
    /**
     * A Boolean value that determines whether the user must enter
     * information when they redeem the reward. Is **true** if the user is
     * prompted.
     */
    "isUserInputRequired": it["is_user_input_required"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per live stream.
     */
    "maxPerStreamSetting": it["max_per_stream_setting"],
    /**
     * The settings used to determine whether to apply a maximum to the
     * number of redemptions allowed per user per live stream.
     */
    "maxPerUserPerStreamSetting": it["max_per_user_per_stream_setting"],
    /**
     * The prompt shown to the viewer when they redeem the reward if user
     * input is required. See the `is_user_input_required` field.
     */
    "prompt": it["prompt"],
    /**
     * The number of redemptions redeemed during the current live stream.
     * The number counts against the `max_per_stream_setting` limit. This
     * field is **null** if the broadcaster’s stream isn’t live or
     * _max\_per\_stream\_setting_ isn’t enabled.
     */
    "redemptionsRedeemedCurrentStream": it["redemptions_redeemed_current_stream"],
    /**
     * A Boolean value that determines whether redemptions should be set
     * to FULFILLED status immediately when a reward is redeemed. If
     * **false**, status is set to UNFULFILLED and follows the normal
     * request queue process.
     */
    "shouldRedemptionsSkipRequestQueue": it["should_redemptions_skip_request_queue"],
    /**
     * The title of the reward.
     */
    "title": it["title"],

  })).array()
});
export interface UpdateCustomRewardResponse extends z.infer<typeof UpdateCustomRewardResponse> {}

export const GetCustomRewardRedemptionResponse = z.object({
  /**
   * The list of redemptions for the specified reward. The list is empty
   * if there are no redemptions that match the redemption criteria.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "id": z.string(),
    "redeemed_at": z.string(),
    "reward": z.object({
      /**
       * The reward’s cost, in Channel Points.
       */
      "cost": z.number(),
      /**
       * The ID that uniquely identifies the reward.
       */
      "id": z.string(),
      /**
       * The prompt displayed to the viewer if user input is required.
       */
      "prompt": z.string(),
      /**
       * The reward’s title.
       */
      "title": z.string()
    }),
    "status": z.enum(["CANCELED", "FULFILLED", "UNFULFILLED"]),
    "user_id": z.string(),
    "user_input": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The ID that uniquely identifies this redemption..
     */
    "id": it["id"],
    /**
     * The date and time of when the reward was redeemed, in RFC3339
     * format.
     */
    "redeemedAt": it["redeemed_at"],
    /**
     * An object that describes the reward that the user redeemed.
     */
    "reward": it["reward"],
    /**
     * The state of the redemption. Possible values are:  
     *   
     * * CANCELED
     * * FULFILLED
     * * UNFULFILLED
     */
    "status": it["status"],
    /**
     * The ID of the user that redeemed the reward.
     */
    "userId": it["user_id"],
    /**
     * The text that the user entered at the prompt when they redeemed the
     * reward; otherwise, an empty string if user input was not required.
     */
    "userInput": it["user_input"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array()
});
export interface GetCustomRewardRedemptionResponse extends z.infer<typeof GetCustomRewardRedemptionResponse> {}

export const UpdateRedemptionStatusResponse = z.object({
  /**
   * The list contains the single redemption that you updated.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "id": z.string(),
    "redeemed_at": z.string(),
    "reward": z.object({
      /**
       * The reward’s cost, in Channel Points.
       */
      "cost": z.number(),
      /**
       * The ID that uniquely identifies the reward.
       */
      "id": z.string(),
      /**
       * The prompt displayed to the viewer if user input is required.
       */
      "prompt": z.string(),
      /**
       * The reward’s title.
       */
      "title": z.string()
    }),
    "status": z.enum(["CANCELED", "FULFILLED", "UNFULFILLED"]),
    "user_id": z.string(),
    "user_input": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The ID that uniquely identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The ID that uniquely identifies this redemption..
     */
    "id": it["id"],
    /**
     * The date and time of when the reward was redeemed, in RFC3339
     * format.
     */
    "redeemedAt": it["redeemed_at"],
    /**
     * An object that describes the reward that the user redeemed.
     */
    "reward": it["reward"],
    /**
     * The state of the redemption. Possible values are:  
     *   
     * * CANCELED
     * * FULFILLED
     * * UNFULFILLED
     */
    "status": it["status"],
    /**
     * The ID of the user that redeemed the reward.
     */
    "userId": it["user_id"],
    /**
     * The text that the user entered at the prompt when they redeemed the
     * reward; otherwise, an empty string if user input was not required.
     */
    "userInput": it["user_input"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array()
});
export interface UpdateRedemptionStatusResponse extends z.infer<typeof UpdateRedemptionStatusResponse> {}



export class ChannelPoints {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets a list of custom rewards that the specified broadcaster created.
   * 
   * **NOTE**: A channel may offer a maximum of 50 rewards, which includes both
   * enabled and disabled rewards.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:redemptions** or
   * **channel:manage:redemptions** scope.
   */
  async getCustomReward(options: GetCustomRewardRequest): Promise<GetCustomRewardResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards", this.#twitch.base);
    if (options.id) {
      for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    }
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.onlyManageableRewards) {
      url.searchParams.append("only_manageable_rewards", options.onlyManageableRewards.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetCustomRewardResponse);
  }
  /**
   * Creates a Custom Reward in the broadcaster’s channel. The maximum number
   * of custom rewards per channel is 50, which includes both enabled and
   * disabled rewards.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:redemptions** scope.
   */
  async createCustomRewards(options: CreateCustomRewardsRequest): Promise<CreateCustomRewardsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.background_color = options.backgroundColor;
    body.cost = options.cost;
    body.max_per_user_per_stream = options.maxPerUserPerStream;
    body.prompt = options.prompt;
    body.is_max_per_user_per_stream_enabled = options.isMaxPerUserPerStreamEnabled;
    body.max_per_stream = options.maxPerStream;
    body.is_global_cooldown_enabled = options.isGlobalCooldownEnabled;
    body.is_user_input_required = options.isUserInputRequired;
    body.is_max_per_stream_enabled = options.isMaxPerStreamEnabled;
    body.is_enabled = options.isEnabled;
    body.should_redemptions_skip_request_queue = options.shouldRedemptionsSkipRequestQueue;
    body.global_cooldown_seconds = options.globalCooldownSeconds;
    body.title = options.title;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, CreateCustomRewardsResponse);
  }
  /**
   * Deletes a custom reward that the broadcaster created.
   * 
   * The app used to create the reward is the only app that may delete it. If
   * the reward’s redemption status is UNFULFILLED at the time the reward is
   * deleted, its redemption status is marked as FULFILLED.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:redemptions** scope.
   */
  async deleteCustomReward(options: DeleteCustomRewardRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("id", options.id.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Updates a custom reward. The app used to create the reward is the only app
   * that may update the reward.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens)
   * that includes the **channel:manage:redemptions** scope.
   * 
   * __Request Body:__
   * 
   * The body of the request should contain only the fields you’re updating.
   */
  async updateCustomReward(options: UpdateCustomRewardRequest): Promise<UpdateCustomRewardResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("id", options.id.toString());
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.global_cooldown_seconds = options.globalCooldownSeconds;
    body.is_max_per_user_per_stream_enabled = options.isMaxPerUserPerStreamEnabled;
    body.is_max_per_stream_enabled = options.isMaxPerStreamEnabled;
    body.is_enabled = options.isEnabled;
    body.background_color = options.backgroundColor;
    body.max_per_stream = options.maxPerStream;
    body.max_per_user_per_stream = options.maxPerUserPerStream;
    body.is_global_cooldown_enabled = options.isGlobalCooldownEnabled;
    body.should_redemptions_skip_request_queue = options.shouldRedemptionsSkipRequestQueue;
    body.prompt = options.prompt;
    body.cost = options.cost;
    body.title = options.title;
    body.is_paused = options.isPaused;
    body.is_user_input_required = options.isUserInputRequired;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateCustomRewardResponse);
  }
  /**
   * Gets a list of redemptions for the specified custom reward. The app used
   * to create the reward is the only app that may get the redemptions.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:redemptions** or
   * **channel:manage:redemptions** scope.
   */
  async getCustomRewardRedemption(options: GetCustomRewardRedemptionRequest): Promise<GetCustomRewardRedemptionResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards/redemptions", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.id) {
      for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    }
    url.searchParams.append("reward_id", options.rewardId.toString());
    if (options.sort) {
      url.searchParams.append("sort", options.sort.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.status) {
      url.searchParams.append("status", options.status.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetCustomRewardRedemptionResponse);
  }
  /**
   * Updates a redemption’s status. You may update a redemption only if its
   * status is UNFULFILLED. The app used to create the reward is the only app
   * that may update the redemption.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:redemptions** scope.
   */
  async updateRedemptionStatus(options: UpdateRedemptionStatusRequest): Promise<UpdateRedemptionStatusResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channel_points/custom_rewards/redemptions", this.#twitch.base);
    for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    url.searchParams.append("reward_id", options.rewardId.toString());
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'PATCH' };

    const body: Record<string, unknown> = {};

    body.status = options.status;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateRedemptionStatusResponse);
  }
}
