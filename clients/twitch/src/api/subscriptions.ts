
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetBroadcasterSubscriptionsRequest {
  /**
   * The cursor used to get the next page of results. Do not specify if you set
   * the _user\_id_ query parameter. The **Pagination** object in the response
   * contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * Filters the list to include only the specified subscribers. To specify
   * more than one subscriber, include this parameter for each subscriber. For
   * example, `&user_id=1234&user_id=5678`. You may specify a maximum of 100
   * subscribers.
   */
  userId?: string[],
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: string,
  /**
   * The cursor used to get the previous page of results. Do not specify if you
   * set the _user\_id_ query parameter. The **Pagination** object in the
   * response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  before?: string,
}
export interface CheckUserSubscriptionRequest {
  /**
   * The ID of the user that you’re checking to see whether they subscribe to
   * the broadcaster in _broadcaster\_id_. This ID must match the user ID in
   * the access Token.
   */
  userId: string,
  /**
   * The ID of a partner or affiliate broadcaster.
   */
  broadcasterId: string,
}
export const GetBroadcasterSubscriptionsResponse = z.object({
  /**
   * The list of users that subscribe to the broadcaster. The list is
   * empty if the broadcaster has no subscribers.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "gifter_id": z.string(),
    "gifter_login": z.string(),
    "gifter_name": z.string(),
    "is_gift": z.boolean(),
    "plan_name": z.string(),
    "tier": z.enum(["1000", "2000", "3000"]),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * An ID that identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The ID of the user that gifted the subscription to the user. Is an
     * empty string if `is_gift` is **false**.
     */
    "gifterId": it["gifter_id"],
    /**
     * The gifter’s login name. Is an empty string if `is_gift` is
     * **false**.
     */
    "gifterLogin": it["gifter_login"],
    /**
     * The gifter’s display name. Is an empty string if `is_gift` is
     * **false**.
     */
    "gifterName": it["gifter_name"],
    /**
     * A Boolean value that determines whether the subscription is a gift
     * subscription. Is **true** if the subscription was gifted.
     */
    "isGift": it["is_gift"],
    /**
     * The name of the subscription.
     */
    "planName": it["plan_name"],
    /**
     * The type of subscription. Possible values are:  
     *   
     * * 1000 — Tier 1
     * * 2000 — Tier 2
     * * 3000 — Tier 3
     */
    "tier": it["tier"],
    /**
     * An ID that identifies the subscribing user.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next or previous page of results. Use
     * the cursor to set the request’s _after_ or _before_ query
     * parameter depending on whether you’re paging forwards or
     * backwards.
     */
    "cursor": z.string().optional()
  }).optional(),
  /**
   * The current number of subscriber points earned by this broadcaster.
   * Points are based on the subscription tier of each user that
   * subscribes to this broadcaster. For example, a Tier 1 subscription is
   * worth 1 point, Tier 2 is worth 2 points, and Tier 3 is worth 6
   * points. The number of points determines the number of emote slots
   * that are unlocked for the broadcaster (see [Subscriber Emote
   * Slots](https://help.twitch.tv/s/article/subscriber-emote-guide#emoteslots)).
   */
  "points": z.number(),
  /**
   * The total number of users that subscribe to this broadcaster.
   */
  "total": z.number()
});
export interface GetBroadcasterSubscriptionsResponse extends z.infer<typeof GetBroadcasterSubscriptionsResponse> {}

export const CheckUserSubscriptionResponse = z.object({
  /**
   * A list that contains a single object with information about the
   * user’s subscription.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "gifter_id": z.string().optional(),
    "gifter_login": z.string().optional(),
    "gifter_name": z.string().optional(),
    "is_gift": z.boolean(),
    "tier": z.enum(["1000", "2000", "3000"])
  }).transform((it) => ({
    /**
     * An ID that identifies the broadcaster.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * The ID of the user that gifted the subscription. The object
     * includes this field only if `is_gift` is **true**.
     */
    "gifterId": it["gifter_id"],
    /**
     * The gifter’s login name. The object includes this field only if
     * `is_gift` is **true**.
     */
    "gifterLogin": it["gifter_login"],
    /**
     * The gifter’s display name. The object includes this field only if
     * `is_gift` is **true**.
     */
    "gifterName": it["gifter_name"],
    /**
     * A Boolean value that determines whether the subscription is a gift
     * subscription. Is **true** if the subscription was gifted.
     */
    "isGift": it["is_gift"],
    /**
     * The type of subscription. Possible values are:  
     *   
     * * 1000 — Tier 1
     * * 2000 — Tier 2
     * * 3000 — Tier 3
     */
    "tier": it["tier"],

  })).array()
});
export interface CheckUserSubscriptionResponse extends z.infer<typeof CheckUserSubscriptionResponse> {}



export class Subscriptions {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets a list of users that subscribe to the specified broadcaster.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:subscriptions** scope.
   * 
   * A Twitch extensions may use an app access token if the broadcaster has
   * granted the **channel:read:subscriptions** scope from within the Twitch
   * Extensions manager.
   */
  async getBroadcasterSubscriptions(options: GetBroadcasterSubscriptionsRequest): Promise<GetBroadcasterSubscriptionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/subscriptions", this.#twitch.base);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.userId) {
      for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    }
    url.searchParams.append("broadcaster_id", snapshot.userId);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.before) {
      url.searchParams.append("before", options.before.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetBroadcasterSubscriptionsResponse);
  }
  /**
   * Checks whether the user subscribes to the broadcaster’s channel.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **user:read:subscriptions** scope.
   * 
   * A Twitch extensions may use an app access token if the broadcaster has
   * granted the **user:read:subscriptions** scope from within the Twitch
   * Extensions manager.
   */
  async checkUserSubscription(options: CheckUserSubscriptionRequest): Promise<CheckUserSubscriptionResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/subscriptions/user", this.#twitch.base);
    url.searchParams.append("user_id", options.userId.toString());
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, CheckUserSubscriptionResponse);
  }
}
