
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetCheermotesRequest {
  /**
   * The ID of the broadcaster whose custom Cheermotes you want to get. Specify
   * the broadcaster’s ID if you want to include the broadcaster’s
   * Cheermotes in the response (not all broadcasters upload Cheermotes). If
   * not specified, the response contains only global Cheermotes.  
   *   
   * If the broadcaster uploaded Cheermotes, the `type` field in the response
   * is set to **channel\_custom**.
   */
  broadcasterId?: string,
}
export interface GetBitsLeaderboardRequest {
  /**
   * The time period over which data is aggregated (uses the PST time zone).
   * Possible values are:  
   *   
   * * day — A day spans from 00:00:00 on the day specified in _started\_at_
   * and runs through 00:00:00 of the next day.
   * * week — A week spans from 00:00:00 on the Monday of the week specified
   * in _started\_at_ and runs through 00:00:00 of the next Monday.
   * * month — A month spans from 00:00:00 on the first day of the month
   * specified in _started\_at_ and runs through 00:00:00 of the first day of
   * the next month.
   * * year — A year spans from 00:00:00 on the first day of the year
   * specified in _started\_at_ and runs through 00:00:00 of the first day of
   * the next year.
   * * all — Default. The lifetime of the broadcaster's channel.
   */
  period?: | "day"| "week"| "month"| "year"| "all",
  /**
   * The start date, in RFC3339 format, used for determining the aggregation
   * period. Specify this parameter only if you specify the _period_ query
   * parameter. The start date is ignored if _period_ is all.  
   *   
   * Note that the date is converted to PST before being used, so if you set
   * the start time to `2022-01-01T00:00:00.0Z` and _period_ to month, the
   * actual reporting period is December 2021, not January 2022\. If you want
   * the reporting period to be January 2022, you must set the start time to
   * `2022-01-01T08:00:00.0Z` or `2022-01-01T00:00:00.0-08:00`.  
   *   
   * If your start date uses the ‘+’ offset operator (for example,
   * `2022-01-01T00:00:00.0+05:00`), you must URL encode the start date.
   */
  startedAt?: string,
  /**
   * The number of results to return. The minimum count is 1 and the maximum is
   * 100\. The default is 10.
   */
  count?: number,
  /**
   * An ID that identifies a user that cheered bits in the channel. If _count_
   * is greater than 1, the response may include users ranked above and below
   * the specified user. To get the leaderboard’s top leaders, don’t
   * specify a user ID.
   */
  userId?: string,
}
export interface GetExtensionTransactionsRequest {
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: number,
  /**
   * The ID of the extension whose list of transactions you want to get.
   */
  extensionId: string,
  /**
   * A transaction ID used to filter the list of transactions. Specify this
   * parameter for each transaction you want to get. For example,
   * `id=1234&id=5678`. You may specify a maximum of 100 IDs.
   */
  id?: string[],
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
}
export const GetCheermotesResponse = z.object({
  /**
   * The list of Cheermotes. The list is in ascending order by the `order`
   * field’s value.
   */
  "data": z.object({
    "is_charitable": z.boolean(),
    "last_updated": z.string(),
    "order": z.number(),
    "prefix": z.string(),
    "tiers": z.object({
      "can_cheer": z.boolean(),
      "color": z.string(),
      "id": z.enum(["1", "100", "500", "1000", "5000", "10000", "100000"]),
      "images": z.object({
        "dark": z.object({
          "animated": z.object({
            "1": z.string().optional(),
            "1.5": z.string().optional(),
            "2": z.string().optional(),
            "3": z.string().optional(),
            "4": z.string().optional()
          }).optional(),
          "static": z.object({
            "1": z.string().optional(),
            "1.5": z.string().optional(),
            "2": z.string().optional(),
            "3": z.string().optional(),
            "4": z.string().optional()
          }).optional()
        }).optional(),
        "light": z.object({
          "animated": z.object({
            "1": z.string().optional(),
            "1.5": z.string().optional(),
            "2": z.string().optional(),
            "3": z.string().optional(),
            "4": z.string().optional()
          }).optional(),
          "static": z.object({
            "1": z.string().optional(),
            "1.5": z.string().optional(),
            "2": z.string().optional(),
            "3": z.string().optional(),
            "4": z.string().optional()
          }).optional()
        }).optional()
      }),
      "min_bits": z.number(),
      "show_in_bits_card": z.boolean()
    }).transform((it) => ({
      /**
       * A Boolean value that determines whether users can cheer at this
       * tier level.
       */
      "canCheer": it["can_cheer"],
      /**
       * The hex code of the color associated with this tier level (for
       * example, #979797).
       */
      "color": it["color"],
      /**
       * The tier level. Possible tiers are:  
       *   
       * * 1
       * * 100
       * * 500
       * * 1000
       * * 5000
       * * 10000
       * * 100000
       */
      "id": it["id"],
      "images": it["images"],
      /**
       * The minimum number of Bits that you must cheer at this tier
       * level. The maximum number of Bits that you can cheer at this
       * level is determined by the required minimum Bits of the next tier
       * level minus 1\. For example, if `min_bits` is 1 and `min_bits`
       * for the next tier is 100, the Bits range for this tier level is 1
       * through 99\. The minimum Bits value of the last tier is the
       * maximum number of Bits you can cheer using this Cheermote. For
       * example, 10000.
       */
      "minBits": it["min_bits"],
      /**
       * A Boolean value that determines whether this tier level is shown
       * in the Bits card. Is **true** if this tier level is shown in the
       * Bits card.
       */
      "showInBitsCard": it["show_in_bits_card"],

    })).array(),
    "type": z.enum(["global_first_party", "global_third_party", "channel_custom", "display_only", "sponsored"])
  }).transform((it) => ({
    /**
     * A Boolean value that indicates whether this Cheermote provides a
     * charitable contribution match during charity campaigns.
     */
    "isCharitable": it["is_charitable"],
    /**
     * The date and time, in RFC3339 format, when this Cheermote was last
     * updated.
     */
    "lastUpdated": it["last_updated"],
    /**
     * The order that the Cheermotes are shown in the Bits card. The
     * numbers may not be consecutive. For example, the numbers may jump
     * from 1 to 7 to 13\. The order numbers are unique within a Cheermote
     * type (for example, global\_first\_party) but may not be unique
     * amongst all Cheermotes in the response.
     */
    "order": it["order"],
    /**
     * The name portion of the Cheermote string that you use in chat to
     * cheer Bits. The full Cheermote string is the concatenation of
     * {prefix} + {number of Bits}. For example, if the prefix is
     * “Cheer” and you want to cheer 100 Bits, the full Cheermote
     * string is Cheer100\. When the Cheermote string is entered in chat,
     * Twitch converts it to the image associated with the Bits tier that
     * was cheered.
     */
    "prefix": it["prefix"],
    /**
     * A list of tier levels that the Cheermote supports. Each tier
     * identifies the range of Bits that you can cheer at that tier level
     * and an image that graphically identifies the tier level.
     */
    "tiers": it["tiers"],
    /**
     * The type of Cheermote. Possible values are:  
     *   
     * * global\_first\_party — A Twitch-defined Cheermote that is shown
     * in the Bits card.
     * * global\_third\_party — A Twitch-defined Cheermote that is not
     * shown in the Bits card.
     * * channel\_custom — A broadcaster-defined Cheermote.
     * * display\_only — Do not use; for internal use only.
     * * sponsored — A sponsor-defined Cheermote. When used, the sponsor
     * adds additional Bits to the amount that the user cheered. For
     * example, if the user cheered Terminator100, the broadcaster might
     * receive 110 Bits, which includes the sponsor's 10 Bits
     * contribution.
     */
    "type": it["type"],

  })).array()
});
export interface GetCheermotesResponse extends z.infer<typeof GetCheermotesResponse> {}

export const GetBitsLeaderboardResponse = z.object({
  "data": z.object({
    "rank": z.number(),
    "score": z.number(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The user’s position on the leaderboard.
     */
    "rank": it["rank"],
    /**
     * The number of Bits the user has cheered.
     */
    "score": it["score"],
    /**
     * An ID that identifies a user on the leaderboard.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  "date_range": z.object({
    "ended_at": z.string(),
    "started_at": z.string()
  }).transform((it) => ({
    /**
     * The reporting window’s end date.
     */
    "endedAt": it["ended_at"],
    /**
     * The reporting window’s start date.
     */
    "startedAt": it["started_at"],

  })),
  "total": z.number()
}).transform((it) => ({
  /**
   * A list of leaderboard leaders. The leaders are returned in rank order
   * by how much they’ve cheered. The array is empty if nobody has
   * cheered bits.
   */
  "data": it["data"],
  /**
   * The reporting window’s start and end dates, in RFC3339 format. The
   * dates are calculated by using the _started\_at_ and _period_ query
   * parameters. If you don’t specify the _started\_at_ query parameter,
   * the fields contain empty strings.
   */
  "dateRange": it["date_range"],
  /**
   * The number of ranked users in `data`. This is the value in the
   * _count_ query parameter or the total number of entries on the
   * leaderboard, whichever is less.
   */
  "total": it["total"],

}));
export interface GetBitsLeaderboardResponse extends z.infer<typeof GetBitsLeaderboardResponse> {}

export const GetExtensionTransactionsResponse = z.object({
  /**
   * The list of transactions.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "id": z.string(),
    "product_data": z.object({
      /**
       * A Boolean value that determines whether the data was broadcast to
       * all instances of the extension. Is **true** if the data was
       * broadcast to all instances.
       */
      "broadcast": z.boolean(),
      /**
       * Contains details about the digital product’s cost.
       */
      "cost": z.object({
        /**
         * The amount exchanged for the digital product.
         */
        "amount": z.number(),
        /**
         * The type of currency exchanged. Possible values are:  
         *   
         * * bits
         */
        "type": z.enum(["bits"])
      }),
      /**
       * The name of the digital product.
       */
      "displayName": z.string(),
      /**
       * Set to `twitch.ext.` \+ `<the extension's ID>`.
       */
      "domain": z.string(),
      /**
       * This field is always empty since you may purchase only unexpired
       * products.
       */
      "expiration": z.string(),
      /**
       * A Boolean value that determines whether the product is in
       * development. Is **true** if the digital product is in development
       * and cannot be exchanged.
       */
      "inDevelopment": z.boolean(),
      /**
       * An ID that identifies the digital product.
       */
      "sku": z.string()
    }),
    "product_type": z.enum(["BITS_IN_EXTENSION"]),
    "timestamp": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The ID of the broadcaster that owns the channel where the
     * transaction occurred.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * An ID that identifies the transaction.
     */
    "id": it["id"],
    /**
     * Contains details about the digital product.
     */
    "productData": it["product_data"],
    /**
     * The type of transaction. Possible values are:  
     *   
     * * BITS\_IN\_EXTENSION
     */
    "productType": it["product_type"],
    /**
     * The UTC date and time (in RFC3339 format) of the transaction.
     */
    "timestamp": it["timestamp"],
    /**
     * The ID of the user that purchased the digital product.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetExtensionTransactionsResponse extends z.infer<typeof GetExtensionTransactionsResponse> {}



export class Bits {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets a list of Cheermotes that users can use to cheer Bits in any
   * Bits-enabled channel’s chat room. Cheermotes are animated emotes that
   * viewers can assign Bits to.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or
   * [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
   */
  async getCheermotes(options: GetCheermotesRequest): Promise<GetCheermotesResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/bits/cheermotes", this.#twitch.base);
    if (options.broadcasterId) {
      url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetCheermotesResponse);
  }
  /**
   * Gets the Bits leaderboard for the authenticated broadcaster.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **bits:read** scope.
   */
  async getBitsLeaderboard(options: GetBitsLeaderboardRequest): Promise<GetBitsLeaderboardResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/bits/leaderboard", this.#twitch.base);
    if (options.period) {
      url.searchParams.append("period", options.period.toString());
    }
    if (options.startedAt) {
      url.searchParams.append("started_at", options.startedAt.toString());
    }
    if (options.count) {
      url.searchParams.append("count", options.count.toString());
    }
    if (options.userId) {
      url.searchParams.append("user_id", options.userId.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetBitsLeaderboardResponse);
  }
  /**
   * Gets an extension’s list of transactions. A transaction records the
   * exchange of a currency (for example, Bits) for a digital product.
   * 
   * __Authorization:__
   * 
   * Requires an [app access
   * token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
   */
  async getExtensionTransactions(options: GetExtensionTransactionsRequest): Promise<GetExtensionTransactionsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/extensions/transactions", this.#twitch.base);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    url.searchParams.append("extension_id", options.extensionId.toString());
    if (options.id) {
      for (const value of options.id) {
      url.searchParams.append("id", value.toString());
    }
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetExtensionTransactionsResponse);
  }
}
