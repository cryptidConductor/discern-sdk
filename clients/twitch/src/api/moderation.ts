
/******************************************************************************
 *
 * !!!WARNING!!!
 *
 * This file is automatically generated. Do not edit this file directly.
 *
 * This file was generated using the twitch generation script, found in the
 * `scripts/twitch` directory of the repository.
 *
 *****************************************************************************/

import type { Twitch } from "../index";
import type { TokenId } from "../types";
import { z } from "zod";

export interface GetVipsRequest {
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100\. The default
   * is 20.
   */
  first?: number,
  /**
   * Filters the list for specific VIPs. To specify more than one user, include
   * the _user\_id_ parameter for each user to get. For example,
   * `&user_id=1234&user_id=5678`. The maximum number of IDs that you may
   * specify is 100\. Ignores the ID of those users in the list that aren’t
   * VIPs.
   */
  userId?: string[],
}
export interface AddChannelVipRequest {
  /**
   * The ID of the user to give VIP status to.
   */
  userId: string,
}
export interface RemoveChannelVipRequest {
  /**
   * The ID of the broadcaster who owns the channel where the user has VIP
   * status.
   */
  broadcasterId: string,
  /**
   * The ID of the user to remove VIP status from.
   */
  userId: string,
}
export interface ManageHeldAutomodMessagesRequest {
  /**
   * The ID of the message to allow or deny.
   */
  msgId: string,
  /**
   * The action to take for the message. Possible values are:  
   *   
   * * ALLOW
   * * DENY
   */
  action: | "ALLOW"| "DENY",
}
export interface GetAutomodSettingsRequest {
  /**
   * The ID of the broadcaster whose AutoMod settings you want to get.
   */
  broadcasterId: string,
}
export interface UpdateAutomodSettingsRequest {
  /**
   * The Automod level for discrimination against disability.
   */
  disability?: number,
  /**
   * The default AutoMod level for the broadcaster.
   */
  overallLevel?: number,
  /**
   * The Automod level for sexual content.
   */
  sexBasedTerms?: number,
  /**
   * The Automod level for hostility involving name calling or insults.
   */
  bullying?: number,
  /**
   * The AutoMod level for discrimination based on sexuality, sex, or gender.
   */
  sexualitySexOrGender?: number,
  /**
   * The Automod level for profanity.
   */
  swearing?: number,
  /**
   * The ID of the broadcaster whose AutoMod settings you want to update.
   */
  broadcasterId: string,
  /**
   * The Automod level for discrimination against women.
   */
  misogyny?: number,
  /**
   * The Automod level for racial discrimination.
   */
  raceEthnicityOrReligion?: number,
  /**
   * The Automod level for hostility involving aggression.
   */
  aggression?: number,
}
export interface GetBannedUsersRequest {
  /**
   * The cursor used to get the previous page of results. The **Pagination**
   * object in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  before?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: number,
  /**
   * A list of user IDs used to filter the results. To specify more than one
   * ID, include this parameter for each user you want to get. For example,
   * `user_id=1234&user_id=5678`. You may specify a maximum of 100 IDs.  
   *   
   * The returned list includes only those users that were banned or put in a
   * timeout. The list is returned in the same order that you specified the
   * IDs.
   */
  userId?: string[],
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
}
export interface BanUserRequest {
  /**
   * Identifies the user and type of ban.
   */
  data: {
  /**
   * To ban a user indefinitely, don’t include this field.  
   *   
   * To put a user in a timeout, include this field and specify the
   * timeout period, in seconds. The minimum timeout is 1 second and the
   * maximum is 1,209,600 seconds (2 weeks).  
   *   
   * To end a user’s timeout early, set this field to 1, or use the
   * [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user)
   * endpoint.
   */
  duration?: number,
  /**
   * The reason the you’re banning the user or putting them in a
   * timeout. The text is user defined and is limited to a maximum of 500
   * characters.
   */
  reason?: string,
  /**
   * The ID of the user to ban or put in a timeout.
   */
  userId: string
},
  /**
   * The ID of the broadcaster whose chat room the user is being banned from.
   */
  broadcasterId: string,
}
export interface UnbanUserRequest {
  /**
   * The ID of the broadcaster whose chat room the user is banned from chatting
   * in.
   */
  broadcasterId: string,
  /**
   * The ID of the user to remove the ban or timeout from.
   */
  userId: string,
}
export interface GetBlockedTermsRequest {
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value.
   */
  after?: string,
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: number,
  /**
   * The ID of the broadcaster whose blocked terms you’re getting.
   */
  broadcasterId: string,
}
export interface AddBlockedTermRequest {
  /**
   * The ID of the broadcaster that owns the list of blocked terms.
   */
  broadcasterId: string,
  /**
   * The word or phrase to block from being used in the broadcaster’s chat
   * room. The term must contain a minimum of 2 characters and may contain up
   * to a maximum of 500 characters.  
   *   
   * Terms may include a wildcard character (\*). The wildcard character must
   * appear at the beginning or end of a word or set of characters. For
   * example, \*foo or foo\*.  
   *   
   * If the blocked term already exists, the response contains the existing
   * blocked term.
   */
  text: string,
}
export interface RemoveBlockedTermRequest {
  /**
   * The ID of the blocked term to remove from the broadcaster’s list of
   * blocked terms.
   */
  id: string,
  /**
   * The ID of the broadcaster that owns the list of blocked terms.
   */
  broadcasterId: string,
}
export interface GetModeratedChannelsRequest {
  /**
   * The maximum number of items to return per page in the response.  
   *   
   * Minimum page size is 1 item per page and the maximum is 100\. The default
   * is 20.
   */
  first?: number,
  /**
   * A user’s ID. Returns the list of channels that this user has moderator
   * privileges in. This ID must match the user ID in the user OAuth token
   */
  userId: string,
  /**
   * The cursor used to get the next page of results. The Pagination object in
   * the response contains the cursor’s value.
   */
  after?: string,
}
export interface DeleteChatMessagesRequest {
  /**
   * The ID of the broadcaster that owns the chat room to remove messages from.
   */
  broadcasterId: string,
  /**
   * The ID of the message to remove. The `id` tag in the
   * [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains
   * the message’s ID. Restrictions:  
   *   
   * * The message must have been created within the last 6 hours.
   * * The message must not belong to the broadcaster.
   * * The message must not belong to another moderator.
   *   
   * If not specified, the request removes all messages in the broadcaster’s
   * chat room.
   */
  messageId?: string,
}
export interface CheckAutomodStatusRequest {
  /**
   * The list of messages to check. The list must contain at least one message
   * and may contain up to a maximum of 100 messages.
   */
  data: {
  /**
   * A caller-defined ID used to correlate this message with the same
   * message in the response.
   */
  msgId: string,
  /**
   * The message to check.
   */
  msgText: string
}[],
}
export interface GetModeratorsRequest {
  /**
   * The maximum number of items to return per page in the response. The
   * minimum page size is 1 item per page and the maximum is 100 items per
   * page. The default is 20.
   */
  first?: string,
  /**
   * The cursor used to get the next page of results. The **Pagination** object
   * in the response contains the cursor’s value. [Read
   * More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  after?: string,
  /**
   * A list of user IDs used to filter the results. To specify more than one
   * ID, include this parameter for each moderator you want to get. For
   * example, `user_id=1234&user_id=5678`. You may specify a maximum of 100
   * IDs.  
   *   
   * The returned list includes only the users from the list who are moderators
   * in the broadcaster’s channel. The list is returned in the same order as
   * you specified the IDs.
   */
  userId?: string[],
}
export interface AddChannelModeratorRequest {
  /**
   * The ID of the user to add as a moderator in the broadcaster’s chat room.
   */
  userId: string,
}
export interface RemoveChannelModeratorRequest {
  /**
   * The ID of the user to remove as a moderator from the broadcaster’s chat
   * room.
   */
  userId: string,
}
export interface GetShieldModeStatusRequest {
  /**
   * The ID of the broadcaster whose Shield Mode activation status you want to
   * get.
   */
  broadcasterId: string,
}
export interface UpdateShieldModeStatusRequest {
  /**
   * The ID of the broadcaster whose Shield Mode you want to activate or
   * deactivate.
   */
  broadcasterId: string,
  /**
   * A Boolean value that determines whether to activate Shield Mode. Set to
   * **true** to activate Shield Mode; otherwise, **false** to deactivate
   * Shield Mode.
   */
  isActive: boolean,
}
export interface GetUnbanRequestsRequest {
  /**
   * Filter by a status.  
   *   
   * * pending
   * * approved
   * * denied
   * * acknowledged
   * * canceled
   */
  status: string,
  /**
   * The maximum number of items to return per page in response
   */
  first?: number,
  /**
   * The ID used to filter what unban requests are returned.
   */
  userId?: string,
  /**
   * The ID of the broadcaster whose channel is receiving unban requests.
   */
  broadcasterId: string,
  /**
   * Cursor used to get next page of results. Pagination object in response
   * contains cursor value.
   */
  after?: string,
}
export interface ResolveUnbanRequestsRequest {
  /**
   * Resolution status.   
   *   
   * * approved
   * * denied
   */
  status: string,
  /**
   * The ID of the broadcaster whose channel is approving or denying the unban
   * request.
   */
  broadcasterId: string,
  /**
   * Message supplied by the unban request resolver. The message is limited to
   * a maximum of 500 characters.
   */
  resolutionText?: string,
}
export interface WarnChatUserRequest {
  /**
   * The ID of the twitch user who requested the warning.
   */
  moderatorId: string,
  /**
   * A list that contains information about the warning.
   */
  data: {
  /**
   * A custom reason for the warning. **Max 500 chars.**
   */
  reason: string,
  /**
   * The ID of the twitch user to be warned.
   */
  userId: string
},
  /**
   * The ID of the channel in which the warning will take effect.
   */
  broadcasterId: string,
}
export const GetVipsResponse = z.object({
  /**
   * The list of VIPs. The list is empty if the broadcaster doesn’t have
   * VIP users.
   */
  "data": z.object({
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * An ID that uniquely identifies the VIP user.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetVipsResponse extends z.infer<typeof GetVipsResponse> {}

export const GetAutomodSettingsResponse = z.object({
  /**
   * The list of AutoMod settings. The list contains a single object that
   * contains all the AutoMod settings.
   */
  "data": z.object({
    "aggression": z.number(),
    "broadcaster_id": z.string(),
    "bullying": z.number(),
    "disability": z.number(),
    "misogyny": z.number(),
    "moderator_id": z.string(),
    "overall_level": z.number(),
    "race_ethnicity_or_religion": z.number(),
    "sex_based_terms": z.number(),
    "sexuality_sex_or_gender": z.number(),
    "swearing": z.number()
  }).transform((it) => ({
    /**
     * The Automod level for hostility involving aggression.
     */
    "aggression": it["aggression"],
    /**
     * The broadcaster’s ID.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The Automod level for hostility involving name calling or insults.
     */
    "bullying": it["bullying"],
    /**
     * The Automod level for discrimination against disability.
     */
    "disability": it["disability"],
    /**
     * The Automod level for discrimination against women.
     */
    "misogyny": it["misogyny"],
    /**
     * The moderator’s ID.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The default AutoMod level for the broadcaster. This field is
     * **null** if the broadcaster has set one or more of the individual
     * settings.
     */
    "overallLevel": it["overall_level"],
    /**
     * The Automod level for racial discrimination.
     */
    "raceEthnicityOrReligion": it["race_ethnicity_or_religion"],
    /**
     * The Automod level for sexual content.
     */
    "sexBasedTerms": it["sex_based_terms"],
    /**
     * The AutoMod level for discrimination based on sexuality, sex, or
     * gender.
     */
    "sexualitySexOrGender": it["sexuality_sex_or_gender"],
    /**
     * The Automod level for profanity.
     */
    "swearing": it["swearing"],

  })).array()
});
export interface GetAutomodSettingsResponse extends z.infer<typeof GetAutomodSettingsResponse> {}

export const UpdateAutomodSettingsResponse = z.object({
  /**
   * The list of AutoMod settings. The list contains a single object that
   * contains all the AutoMod settings.
   */
  "data": z.object({
    "aggression": z.number(),
    "broadcaster_id": z.string(),
    "bullying": z.number(),
    "disability": z.number(),
    "misogyny": z.number(),
    "moderator_id": z.string(),
    "overall_level": z.number(),
    "race_ethnicity_or_religion": z.number(),
    "sex_based_terms": z.number(),
    "sexuality_sex_or_gender": z.number(),
    "swearing": z.number()
  }).transform((it) => ({
    /**
     * The Automod level for hostility involving aggression.
     */
    "aggression": it["aggression"],
    /**
     * The broadcaster’s ID.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The Automod level for hostility involving name calling or insults.
     */
    "bullying": it["bullying"],
    /**
     * The Automod level for discrimination against disability.
     */
    "disability": it["disability"],
    /**
     * The Automod level for discrimination against women.
     */
    "misogyny": it["misogyny"],
    /**
     * The moderator’s ID.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The default AutoMod level for the broadcaster. This field is
     * **null** if the broadcaster has set one or more of the individual
     * settings.
     */
    "overallLevel": it["overall_level"],
    /**
     * The Automod level for racial discrimination.
     */
    "raceEthnicityOrReligion": it["race_ethnicity_or_religion"],
    /**
     * The Automod level for sexual content.
     */
    "sexBasedTerms": it["sex_based_terms"],
    /**
     * The AutoMod level for discrimination based on sexuality, sex, or
     * gender.
     */
    "sexualitySexOrGender": it["sexuality_sex_or_gender"],
    /**
     * The Automod level for profanity.
     */
    "swearing": it["swearing"],

  })).array()
});
export interface UpdateAutomodSettingsResponse extends z.infer<typeof UpdateAutomodSettingsResponse> {}

export const GetBannedUsersResponse = z.object({
  /**
   * The list of users that were banned or put in a timeout.
   */
  "data": z.object({
    "created_at": z.string(),
    "expires_at": z.string(),
    "moderator_id": z.string(),
    "moderator_login": z.string(),
    "moderator_name": z.string(),
    "reason": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The UTC date and time (in RFC3339 format) of when the user was
     * banned.
     */
    "createdAt": it["created_at"],
    /**
     * The UTC date and time (in RFC3339 format) of when the timeout
     * expires, or an empty string if the user is permanently banned.
     */
    "expiresAt": it["expires_at"],
    /**
     * The ID of the moderator that banned the user or put them in a
     * timeout.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The moderator’s login name.
     */
    "moderatorLogin": it["moderator_login"],
    /**
     * The moderator’s display name.
     */
    "moderatorName": it["moderator_name"],
    /**
     * The reason the user was banned or put in a timeout if the moderator
     * provided one.
     */
    "reason": it["reason"],
    /**
     * The ID of the banned user.
     */
    "userId": it["user_id"],
    /**
     * The banned user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The banned user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetBannedUsersResponse extends z.infer<typeof GetBannedUsersResponse> {}

export const BanUserResponse = z.object({
  /**
   * A list that contains the user you successfully banned or put in a
   * timeout.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "created_at": z.string(),
    "end_time": z.string(),
    "moderator_id": z.string(),
    "user_id": z.string()
  }).transform((it) => ({
    /**
     * The broadcaster whose chat room the user was banned from chatting
     * in.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The UTC date and time (in RFC3339 format) that the ban or timeout
     * was placed.
     */
    "createdAt": it["created_at"],
    /**
     * The UTC date and time (in RFC3339 format) that the timeout will
     * end. Is **null** if the user was banned instead of being put in a
     * timeout.
     */
    "endTime": it["end_time"],
    /**
     * The moderator that banned or put the user in the timeout.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The user that was banned or put in a timeout.
     */
    "userId": it["user_id"],

  })).array()
});
export interface BanUserResponse extends z.infer<typeof BanUserResponse> {}

export const GetBlockedTermsResponse = z.object({
  /**
   * The list of blocked terms. The list is in descending order of when
   * they were created (see the `created_at` timestamp).
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "created_at": z.string(),
    "expires_at": z.string(),
    "id": z.string(),
    "moderator_id": z.string(),
    "text": z.string(),
    "updated_at": z.string()
  }).transform((it) => ({
    /**
     * The broadcaster that owns the list of blocked terms.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The UTC date and time (in RFC3339 format) that the term was
     * blocked.
     */
    "createdAt": it["created_at"],
    /**
     * The UTC date and time (in RFC3339 format) that the blocked term is
     * set to expire. After the block expires, users may use the term in
     * the broadcaster’s chat room.  
     *   
     * This field is **null** if the term was added manually or was
     * permanently blocked by AutoMod.
     */
    "expiresAt": it["expires_at"],
    /**
     * An ID that identifies this blocked term.
     */
    "id": it["id"],
    /**
     * The moderator that blocked the word or phrase from being used in
     * the broadcaster’s chat room.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The blocked word or phrase.
     */
    "text": it["text"],
    /**
     * The UTC date and time (in RFC3339 format) that the term was
     * updated.  
     *   
     * When the term is added, this timestamp is the same as `created_at`.
     * The timestamp changes as AutoMod continues to deny the term.
     */
    "updatedAt": it["updated_at"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetBlockedTermsResponse extends z.infer<typeof GetBlockedTermsResponse> {}

export const AddBlockedTermResponse = z.object({
  /**
   * A list that contains the single blocked term that the broadcaster
   * added.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "created_at": z.string(),
    "expires_at": z.string(),
    "id": z.string(),
    "moderator_id": z.string(),
    "text": z.string(),
    "updated_at": z.string()
  }).transform((it) => ({
    /**
     * The broadcaster that owns the list of blocked terms.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The UTC date and time (in RFC3339 format) that the term was
     * blocked.
     */
    "createdAt": it["created_at"],
    /**
     * The UTC date and time (in RFC3339 format) that the blocked term is
     * set to expire. After the block expires, users may use the term in
     * the broadcaster’s chat room.  
     *   
     * This field is **null** if the term was added manually or was
     * permanently blocked by AutoMod.
     */
    "expiresAt": it["expires_at"],
    /**
     * An ID that identifies this blocked term.
     */
    "id": it["id"],
    /**
     * The moderator that blocked the word or phrase from being used in
     * the broadcaster’s chat room.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The blocked word or phrase.
     */
    "text": it["text"],
    /**
     * The UTC date and time (in RFC3339 format) that the term was
     * updated.  
     *   
     * When the term is added, this timestamp is the same as `created_at`.
     * The timestamp changes as AutoMod continues to deny the term.
     */
    "updatedAt": it["updated_at"],

  })).array()
});
export interface AddBlockedTermResponse extends z.infer<typeof AddBlockedTermResponse> {}

export const GetModeratedChannelsResponse = z.object({
  /**
   * The list of channels that the user has moderator privileges in.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string()
  }).transform((it) => ({
    /**
     * An ID that uniquely identifies the channel this user can moderate.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The channel’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The channels’ display name.
     */
    "broadcasterName": it["broadcaster_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s after query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetModeratedChannelsResponse extends z.infer<typeof GetModeratedChannelsResponse> {}

export const CheckAutomodStatusResponse = z.object({
  /**
   * The list of messages and whether Twitch would approve them for chat.
   */
  "data": z.object({
    "is_permitted": z.boolean(),
    "msg_id": z.string()
  }).transform((it) => ({
    /**
     * A Boolean value that indicates whether Twitch would approve the
     * message for chat or hold it for moderator review or block it from
     * chat. Is **true** if Twitch would approve the message; otherwise,
     * **false** if Twitch would hold the message for moderator review or
     * block it from chat.
     */
    "isPermitted": it["is_permitted"],
    /**
     * The caller-defined ID passed in the request.
     */
    "msgId": it["msg_id"],

  })).array()
});
export interface CheckAutomodStatusResponse extends z.infer<typeof CheckAutomodStatusResponse> {}

export const GetModeratorsResponse = z.object({
  /**
   * The list of moderators.
   */
  "data": z.object({
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * The ID of the user that has permission to moderate the
     * broadcaster’s channel.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains the information used to page through the list of results.
   * The object is empty if there are no more pages left to page through.
   * [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s _after_ query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetModeratorsResponse extends z.infer<typeof GetModeratorsResponse> {}

export const GetShieldModeStatusResponse = z.object({
  /**
   * A list that contains a single object with the broadcaster’s Shield
   * Mode status.
   */
  "data": z.object({
    "is_active": z.boolean(),
    "last_activated_at": z.string(),
    "moderator_id": z.string(),
    "moderator_login": z.string(),
    "moderator_name": z.string()
  }).transform((it) => ({
    /**
     * A Boolean value that determines whether Shield Mode is active. Is
     * **true** if the broadcaster activated Shield Mode; otherwise,
     * **false**.
     */
    "isActive": it["is_active"],
    /**
     * The UTC timestamp (in RFC3339 format) of when Shield Mode was last
     * activated. Is an empty string if Shield Mode hasn’t been
     * previously activated.
     */
    "lastActivatedAt": it["last_activated_at"],
    /**
     * An ID that identifies the moderator that last activated Shield
     * Mode. Is an empty string if Shield Mode hasn’t been previously
     * activated.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The moderator’s login name. Is an empty string if Shield Mode
     * hasn’t been previously activated.
     */
    "moderatorLogin": it["moderator_login"],
    /**
     * The moderator’s display name. Is an empty string if Shield Mode
     * hasn’t been previously activated.
     */
    "moderatorName": it["moderator_name"],

  })).array()
});
export interface GetShieldModeStatusResponse extends z.infer<typeof GetShieldModeStatusResponse> {}

export const UpdateShieldModeStatusResponse = z.object({
  /**
   * A list that contains a single object with the broadcaster’s updated
   * Shield Mode status.
   */
  "data": z.object({
    "is_active": z.boolean(),
    "last_activated_at": z.string(),
    "moderator_id": z.string(),
    "moderator_login": z.string(),
    "moderator_name": z.string()
  }).transform((it) => ({
    /**
     * A Boolean value that determines whether Shield Mode is active. Is
     * **true** if Shield Mode is active; otherwise, **false**.
     */
    "isActive": it["is_active"],
    /**
     * The UTC timestamp (in RFC3339 format) of when Shield Mode was last
     * activated.
     */
    "lastActivatedAt": it["last_activated_at"],
    /**
     * An ID that identifies the moderator that last activated Shield
     * Mode.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The moderator’s login name.
     */
    "moderatorLogin": it["moderator_login"],
    /**
     * The moderator’s display name.
     */
    "moderatorName": it["moderator_name"],

  })).array()
});
export interface UpdateShieldModeStatusResponse extends z.infer<typeof UpdateShieldModeStatusResponse> {}

export const GetUnbanRequestsResponse = z.object({
  /**
   * A list that contains information about the channel's unban requests.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "created_at": z.string(),
    "id": z.string(),
    "moderator_id": z.string(),
    "moderator_login": z.string(),
    "moderator_name": z.string(),
    "resolution_text": z.string(),
    "resolved_at": z.string(),
    "status": z.string(),
    "text": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * User ID of broadcaster whose channel is receiving the unban
     * request.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster's login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster's display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * Timestamp of when the unban request was created.
     */
    "createdAt": it["created_at"],
    /**
     * Unban request ID.
     */
    "id": it["id"],
    /**
     * User ID of moderator who approved/denied the request.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The moderator's login name.
     */
    "moderatorLogin": it["moderator_login"],
    /**
     * The moderator's display name.
     */
    "moderatorName": it["moderator_name"],
    /**
     * Text input by the resolver (moderator) of the unban. request
     */
    "resolutionText": it["resolution_text"],
    /**
     * Timestamp of when moderator/broadcaster approved or denied the
     * request.
     */
    "resolvedAt": it["resolved_at"],
    /**
     * Status of the request. One of:  
     *   
     * * pending
     * * approved
     * * denied
     * * acknowledged
     * * canceled
     */
    "status": it["status"],
    /**
     * Text of the request from the requesting user.
     */
    "text": it["text"],
    /**
     * User ID of the requestor who is asking for an unban.
     */
    "userId": it["user_id"],
    /**
     * The user's login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user's display name.
     */
    "userName": it["user_name"],

  })).array(),
  /**
   * Contains information used to page through a list of results. The
   * object is empty if there are no more pages left to page through.
   */
  "pagination": z.object({
    /**
     * The cursor used to get the next page of results. Use the cursor to
     * set the request’s after query parameter.
     */
    "cursor": z.string().optional()
  }).optional()
});
export interface GetUnbanRequestsResponse extends z.infer<typeof GetUnbanRequestsResponse> {}

export const ResolveUnbanRequestsResponse = z.object({
  /**
   * 
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "broadcaster_login": z.string(),
    "broadcaster_name": z.string(),
    "created_at": z.string(),
    "id": z.string(),
    "moderator_id": z.string(),
    "moderator_login": z.string(),
    "moderator_name": z.string(),
    "resolution_text": z.string(),
    "resolved_at": z.string(),
    "status": z.string(),
    "text": z.string(),
    "user_id": z.string(),
    "user_login": z.string(),
    "user_name": z.string()
  }).transform((it) => ({
    /**
     * User ID of broadcaster whose channel is receiving the unban
     * request.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The broadcaster’s login name.
     */
    "broadcasterLogin": it["broadcaster_login"],
    /**
     * The broadcaster’s display name.
     */
    "broadcasterName": it["broadcaster_name"],
    /**
     * Timestamp of when the unban request was created.
     */
    "createdAt": it["created_at"],
    /**
     * Unban request ID.
     */
    "id": it["id"],
    /**
     * User ID of moderator who approved/denied the request.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The moderator’s login name.
     */
    "moderatorLogin": it["moderator_login"],
    /**
     * The moderator’s display name.
     */
    "moderatorName": it["moderator_name"],
    /**
     * Text input by the resolver (moderator) of the unban request.
     */
    "resolutionText": it["resolution_text"],
    /**
     * Timestamp of when moderator/broadcaster approved or denied the
     * request.
     */
    "resolvedAt": it["resolved_at"],
    /**
     * Status of the request. One of:   
     *   
     * * approved
     * * denied
     */
    "status": it["status"],
    /**
     * Text of the request from the requesting user.
     */
    "text": it["text"],
    /**
     * User ID of the requestor who is asking for an unban.
     */
    "userId": it["user_id"],
    /**
     * The user’s login name.
     */
    "userLogin": it["user_login"],
    /**
     * The user’s display name.
     */
    "userName": it["user_name"],

  })).array()
});
export interface ResolveUnbanRequestsResponse extends z.infer<typeof ResolveUnbanRequestsResponse> {}

export const WarnChatUserResponse = z.object({
  /**
   * A list that contains information about the warning.
   */
  "data": z.object({
    "broadcaster_id": z.string(),
    "moderator_id": z.string(),
    "reason": z.string(),
    "user_id": z.string()
  }).transform((it) => ({
    /**
     * The ID of the channel in which the warning will take effect.
     */
    "broadcasterId": it["broadcaster_id"],
    /**
     * The ID of the user who applied the warning.
     */
    "moderatorId": it["moderator_id"],
    /**
     * The reason provided for warning.
     */
    "reason": it["reason"],
    /**
     * The ID of the warned user.
     */
    "userId": it["user_id"],

  })).array()
});
export interface WarnChatUserResponse extends z.infer<typeof WarnChatUserResponse> {}



export class Moderation {
  readonly #twitch: Twitch;

  constructor(twitch: Twitch) {
    this.#twitch = twitch;
  }

  /**
   * Gets a list of the broadcaster’s VIPs.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:read:vips** scope. If your app also adds and
   * removes VIP status, you can use the **channel:manage:vips** scope instead.
   */
  async getVips(options: GetVipsRequest): Promise<GetVipsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/vips", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.userId) {
      for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetVipsResponse);
  }
  /**
   * Adds the specified user as a VIP in the broadcaster’s channel.
   * 
   * **Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a
   * 10-second window.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:vips** scope.
   */
  async addChannelVip(options: AddChannelVipRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/vips", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    url.searchParams.append("user_id", options.userId.toString());
    const opts: RequestInit = { method: 'POST' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Removes the specified user as a VIP in the broadcaster’s channel.
   * 
   * If the broadcaster is removing the user’s VIP status, the ID in the
   * _broadcaster\_id_ query parameter must match the user ID in the access
   * token; otherwise, if the user is removing their VIP status themselves, the
   * ID in the _user\_id_ query parameter must match the user ID in the access
   * token.
   * 
   * **Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a
   * 10-second window.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:vips** scope.
   */
  async removeChannelVip(options: RemoveChannelVipRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/channels/vips", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("user_id", options.userId.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Allow or deny the message that AutoMod flagged for review. For information
   * about AutoMod, see [How to Use
   * AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).
   * 
   * To get messages that AutoMod is holding for review, subscribe to the
   * **automod-queue.<moderator\_id>.<channel\_id>**
   * [topic](https://dev.twitch.tv/docs/pubsub#topics) using
   * [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification
   * to your app when AutoMod holds a message for review.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:automod** scope.
   */
  async manageHeldAutomodMessages(options: ManageHeldAutomodMessagesRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/automod/message", this.#twitch.base);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.user_id = snapshot.userId;
    body.msg_id = options.msgId;
    body.action = options.action;
    opts.body = JSON.stringify(body);
    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s AutoMod settings. The settings are used to
   * automatically block inappropriate or harassing messages from appearing in
   * the broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:read:automod\_settings** scope.
   */
  async getAutomodSettings(options: GetAutomodSettingsRequest): Promise<GetAutomodSettingsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/automod/settings", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetAutomodSettingsResponse);
  }
  /**
   * Updates the broadcaster’s AutoMod settings. The settings are used to
   * automatically block inappropriate or harassing messages from appearing in
   * the broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:automod\_settings** scope.
   * 
   * __Request Body:__
   * 
   * Because PUT is an overwrite operation, you must include all the fields
   * that you want set after the operation completes. Typically, you’ll send
   * a GET request, update the fields you want to change, and pass that object
   * in the PUT request.
   * 
   * You may set either `overall_level` or the individual settings like
   * `aggression`, but not both.
   * 
   * Setting `overall_level` applies default values to the individual settings.
   * However, setting `overall_level` to 4 does not necessarily mean that it
   * applies 4 to all the individual settings. Instead, it applies a set of
   * recommended defaults to the rest of the settings. For example, if you set
   * `overall_level` to 2, Twitch provides some filtering on discrimination and
   * sexual content, but more filtering on hostility (see the first example
   * response).
   * 
   * If `overall_level` is currently set and you update `swearing` to 3,
   * `overall_level` will be set to **null** and all settings other than
   * `swearing` will be set to 0\. The same is true if individual settings are
   * set and you update `overall_level` to 3 — all the individual settings
   * are updated to reflect the default level.
   * 
   * Note that if you set all the individual settings to values that match what
   * `overall_level` would have set them to, Twitch changes AutoMod to use the
   * default AutoMod level instead of using the individual settings.
   * 
   * Valid values for all levels are from 0 (no filtering) through 4 (most
   * aggressive filtering). These levels affect how aggressively AutoMod holds
   * back messages for moderators to review before they appear in chat or are
   * denied (not shown).
   */
  async updateAutomodSettings(options: UpdateAutomodSettingsRequest): Promise<UpdateAutomodSettingsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/automod/settings", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.disability = options.disability;
    body.overall_level = options.overallLevel;
    body.sex_based_terms = options.sexBasedTerms;
    body.bullying = options.bullying;
    body.sexuality_sex_or_gender = options.sexualitySexOrGender;
    body.swearing = options.swearing;
    body.misogyny = options.misogyny;
    body.race_ethnicity_or_religion = options.raceEthnicityOrReligion;
    body.aggression = options.aggression;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateAutomodSettingsResponse);
  }
  /**
   * Gets all users that the broadcaster banned or put in a timeout.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderation:read** or **moderator:manage:banned\_users**
   * scope.
   */
  async getBannedUsers(options: GetBannedUsersRequest): Promise<GetBannedUsersResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/banned", this.#twitch.base);
    if (options.before) {
      url.searchParams.append("before", options.before.toString());
    }
    url.searchParams.append("broadcaster_id", snapshot.userId);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.userId) {
      for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetBannedUsersResponse);
  }
  /**
   * Bans a user from participating in the specified broadcaster’s chat room
   * or puts them in a timeout.
   * 
   * For information about banning or putting users in a timeout, see [Ban a
   * User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) 
   * and [Timeout a
   * User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).
   * 
   * If the user is currently in a timeout, you can call this endpoint to
   * change the duration of the timeout or ban them altogether. If the user is
   * currently banned, you cannot call this method to put them in a timeout
   * instead.
   * 
   * To remove a ban or end a timeout, see [Unban
   * user](https://dev.twitch.tv/docs/api/reference#unban-user).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:banned\_users** scope.
   */
  async banUser(options: BanUserRequest): Promise<BanUserResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/bans", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.data = options.data;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, BanUserResponse);
  }
  /**
   * Removes the ban or timeout that was placed on the specified user.
   * 
   * To ban a user, see [Ban
   * user](https://dev.twitch.tv/docs/api/reference#ban-user).
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:banned\_users** scope.
   */
  async unbanUser(options: UnbanUserRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/bans", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("user_id", options.userId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s list of non-private, blocked words or phrases.
   * These are the terms that the broadcaster or moderator added manually or
   * that were denied by AutoMod.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:read:blocked\_terms** or
   * **moderator:manage:blocked\_terms** scope.
   */
  async getBlockedTerms(options: GetBlockedTermsRequest): Promise<GetBlockedTermsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/blocked_terms", this.#twitch.base);
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetBlockedTermsResponse);
  }
  /**
   * Adds a word or phrase to the broadcaster’s list of blocked terms. These
   * are the terms that the broadcaster doesn’t want used in their chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:blocked\_terms** scope.
   */
  async addBlockedTerm(options: AddBlockedTermRequest): Promise<AddBlockedTermResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/blocked_terms", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.text = options.text;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, AddBlockedTermResponse);
  }
  /**
   * Removes the word or phrase from the broadcaster’s list of blocked terms.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:blocked\_terms** scope.
   */
  async removeBlockedTerm(options: RemoveBlockedTermRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/blocked_terms", this.#twitch.base);
    url.searchParams.append("id", options.id.toString());
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Gets a list of channels that the specified user has moderator privileges
   * in.
   * 
   * __Authorization:__
   * 
   * * Query parameter `user_id` must match the user ID in the [User-Access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
   * * Requires OAuth Scope: `user:read:moderated_channels`
   */
  async getModeratedChannels(options: GetModeratedChannelsRequest): Promise<GetModeratedChannelsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/channels", this.#twitch.base);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    url.searchParams.append("user_id", options.userId.toString());
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetModeratedChannelsResponse);
  }
  /**
   * Removes a single chat message or all chat messages from the
   * broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:chat\_messages** scope.
   */
  async deleteChatMessages(options: DeleteChatMessagesRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/chat", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    if (options.messageId) {
      url.searchParams.append("message_id", options.messageId.toString());
    }
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Checks whether AutoMod would flag the specified message for review.
   * 
   * AutoMod is a moderation tool that holds inappropriate or harassing chat
   * messages for moderators to review. Moderators approve or deny the messages
   * that AutoMod flags; only approved messages are released to chat. AutoMod
   * detects misspellings and evasive language automatically. For information
   * about AutoMod, see [How to Use
   * AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).
   * 
   * **Rate Limits**: Rates are limited per channel based on the account type
   * rather than per access token.
   * 
   * | Account type | Limit per minute | Limit per hour |
   * | - | - | - |
   * | Normal | 5 | 50 |
   * | Affiliate | 10 | 100 |
   * | Partner | 30 | 300 |
   * 
   * 
   * The above limits are in addition to the standard [Twitch API rate
   * limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate
   * limit headers in the response represent the Twitch rate limits and not the
   * above limits.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderation:read** scope.
   */
  async checkAutomodStatus(options: CheckAutomodStatusRequest): Promise<CheckAutomodStatusResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/enforcements/status", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.data = options.data;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, CheckAutomodStatusResponse);
  }
  /**
   * Gets all users allowed to moderate the broadcaster’s chat room.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderation:read** scope. If your app also adds and removes
   * moderators, you can use the **channel:manage:moderators** scope instead.
   */
  async getModerators(options: GetModeratorsRequest): Promise<GetModeratorsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/moderators", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    if (options.userId) {
      for (const value of options.userId) {
      url.searchParams.append("user_id", value.toString());
    }
    }
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetModeratorsResponse);
  }
  /**
   * Adds a moderator to the broadcaster’s chat room.
   * 
   * **Rate Limits**: The broadcaster may add a maximum of 10 moderators within
   * a 10-second window.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:moderators** scope.
   */
  async addChannelModerator(options: AddChannelModeratorRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/moderators", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    url.searchParams.append("user_id", options.userId.toString());
    const opts: RequestInit = { method: 'POST' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Removes a moderator from the broadcaster’s chat room.
   * 
   * **Rate Limits**: The broadcaster may remove a maximum of 10 moderators
   * within a 10-second window.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **channel:manage:moderators** scope.
   */
  async removeChannelModerator(options: RemoveChannelModeratorRequest): Promise<void> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/moderators", this.#twitch.base);
    url.searchParams.append("broadcaster_id", snapshot.userId);
    url.searchParams.append("user_id", options.userId.toString());
    const opts: RequestInit = { method: 'DELETE' };

    await this.#twitch.request(url, opts);
  }
  /**
   * Gets the broadcaster’s Shield Mode activation status.
   * 
   * To receive notification when the broadcaster activates and deactivates
   * Shield Mode, subscribe to the
   * [channel.shield\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) 
   * and
   * [channel.shield\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) 
   * subscription types.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:read:shield\_mode** or
   * **moderator:manage:shield\_mode** scope.
   */
  async getShieldModeStatus(options: GetShieldModeStatusRequest): Promise<GetShieldModeStatusResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/shield_mode", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetShieldModeStatusResponse);
  }
  /**
   * Activates or deactivates the broadcaster’s Shield Mode.
   * 
   * Twitch’s Shield Mode feature is like a panic button that broadcasters
   * can push to protect themselves from chat abuse coming from one or more
   * accounts. When activated, Shield Mode applies the overrides that the
   * broadcaster configured in the Twitch UX. If the broadcaster hasn’t
   * configured Shield Mode, it applies default overrides.
   * 
   * __Authorization:__
   * 
   * Requires a [user access
   * token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that
   * includes the **moderator:manage:shield\_mode** scope.
   */
  async updateShieldModeStatus(options: UpdateShieldModeStatusRequest): Promise<UpdateShieldModeStatusResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/shield_mode", this.#twitch.base);
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'PUT' };

    const body: Record<string, unknown> = {};

    body.is_active = options.isActive;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, UpdateShieldModeStatusResponse);
  }
  /**
   * NEW Gets a list of unban requests for a broadcaster’s channel.
   * 
   * __Authorization:__
   * 
   * * Requires a user access token that includes the
   * **moderator:read:unban\_requests** or **moderator:manage:unban\_requests**
   * scope.
   * * Query parameter `moderator_id` must match the `user_id` in the [user
   * access
   * token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
   */
  async getUnbanRequests(options: GetUnbanRequestsRequest): Promise<GetUnbanRequestsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/unban_requests", this.#twitch.base);
    url.searchParams.append("status", options.status.toString());
    if (options.first) {
      url.searchParams.append("first", options.first.toString());
    }
    if (options.userId) {
      url.searchParams.append("user_id", options.userId.toString());
    }
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.after) {
      url.searchParams.append("after", options.after.toString());
    }
    url.searchParams.append("moderator_id", snapshot.userId);
    const opts: RequestInit = { method: 'GET' };

    return await this.#twitch.request(url, opts, GetUnbanRequestsResponse);
  }
  /**
   * NEW Resolves an unban request by approving or denying it.
   * 
   * __Authorization:__
   * 
   * * Requires a user access token that includes the
   * **moderator:manage:unban\\\_requests** scope.
   * * Query parameter `moderator_id` must match the `user_id` in the[user
   * access
   * token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
   */
  async resolveUnbanRequests(options: ResolveUnbanRequestsRequest): Promise<ResolveUnbanRequestsResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/unban_requests", this.#twitch.base);
    url.searchParams.append("moderator_id", snapshot.userId);
    url.searchParams.append("status", options.status.toString());
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    if (options.resolutionText) {
      url.searchParams.append("resolution_text", options.resolutionText.toString());
    }
    url.searchParams.append("unban_request_id", snapshot.userId);
    const opts: RequestInit = { method: 'PATCH' };

    return await this.#twitch.request(url, opts, ResolveUnbanRequestsResponse);
  }
  /**
   * NEW Warns a user in the specified broadcaster’s chat room, preventing
   * them from chat interaction until the warning is acknowledged. New warnings
   * can be issued to a user when they already have a warning in the channel
   * (new warning will replace old warning).
   * 
   * __Authorization:__
   * 
   * Requires a user access token that includes the
   * **moderator:manage:warnings** scope. Query parameter `moderator_id` must
   * match the `user_id` in the [user access
   * token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
   */
  async warnChatUser(options: WarnChatUserRequest): Promise<WarnChatUserResponse> {
    const snapshot = await this.#twitch.snapshot();
    const url = new URL("/moderation/warnings", this.#twitch.base);
    url.searchParams.append("moderator_id", options.moderatorId.toString());
    url.searchParams.append("broadcaster_id", options.broadcasterId.toString());
    const opts: RequestInit = { method: 'POST' };

    const body: Record<string, unknown> = {};

    body.data = options.data;
    opts.body = JSON.stringify(body);
    return await this.#twitch.request(url, opts, WarnChatUserResponse);
  }
}
